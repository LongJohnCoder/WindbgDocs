<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/MSHelp">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>Annotated x64 Disassembly</TITLE>
<META NAME="ms.locale" content="en-us">
<META NAME="DESCRIPTION" CONTENT="Debugger, Debugger, Design Guide, Annotated x64 Disassembly"><xml><MSHelp:Keyword Index="A" Term="t09_arch_x86_76f4de05-24cc-4c2a-af64-a7361e8fc2ce.xml"/>
<META NAME="MS-HKWD" CONTENT="x64 processor, annotated disassembly"></xml><LINK REL="stylesheet" type="text/css" href="backsdk4.css"><SCRIPT src="langref.js"></SCRIPT><style>dd {margin-bottom:0em; margin-left:1.9em; }</style>
<style>.divclass {behavior:url(#default#savehistory);}</style>
<META NAME="save" CONTENT="history">
</HEAD>
<Body topmargin="0">
<DIV STYLE="display:none;"></DIV>
<DIV STYLE="display:none;"></DIV>
<TABLE CLASS="buttonbarshade" CELLSPACING="0" border="0"><TR><TD NOWRAP="true"> </TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING="0">
<TR ID="hdr">
<TD NOWRAP="true" CLASS="runninghead">Debugging Tools for Windows</TD>
</TR>
</TABLE>
<H1><A NAME="t09_arch_x86_76f4de05-24cc-4c2a-af64-a7361e8fc2ce.xml"></A>Annotated x64 Disassembly</H1>
<P></P>
<P>The following very simple function illustrates the x64 calling convention.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>int Simple(int i, int j)<BR>{<BR>    return i*5 + j + 3;<BR>}<BR><BR></nobr></P>
<P>This compiles to code like this:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>01001080 lea     eax,[rdx+rcx*4]        ; eax = rdx+rcx*4<BR>01001083 lea     eax,[rcx+rax+0x3]      ; eax = rcx+rax+3<BR>01001087 ret<BR><BR></nobr></P>
<P>The <i>i</i> and <i>j</i> parameters are passed in the <b>ecx</b> and <b>edx</b> registers, respectively.  Since there are only two parameters, the routine does not use the stack at all.</P>
<P>The particular code generated exploits three tricks, one of which is specific to the x64:</P><B></B><OL type="1">
<LI>The <b>lea</b> operation can be used to perform a series of simple arithmetic operations as a single operation.  The first instruction stores <i>j+i</i>*4 in <b>eax</b>, and the second instruction adds <i>i</i>+3 to the result, for a total of <i>j</i>+<i>i</i>*5+3.</LI>
<LI>Many operations, such as addition and multiplication, can be done with extra precision, and then truncated to the correct precision.  In this instance, the code uses 64-bit addition and multiplication.  We can safely truncate the result to 32 bits.</LI>
<LI>On the x64, any operation that outputs to a 32-bit register automatically zero-extends the result.  In this case, outputting to <b>eax</b> has the effect of truncating the result to 32 bits.</LI>
</OL>
<P></P>
<P>Return values are passed in the <b>rax</b> register.  In this case, the result is already in the <b>rax</b> register, so the function returns.</P>
<P>Next we consider a more complicated function to demonstrate typical x64 disassembly:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>HRESULT Meaningless(IDispatch *pdisp, DISPID dispid, BOOL fUnique, LPCWSTR pszExe)<BR>{<BR>    IQueryAssociations *pqa;<BR>    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void**)&amp;pqa);<BR>    if (SUCCEEDED(hr)) {<BR>        hr = pqa-&gt;Init(ASSOCF_INIT_BYEXENAME, pszExe, NULL, NULL);<BR>        if (SUCCEEDED(hr)) {<BR>            WCHAR wszName[MAX_PATH];<BR>            DWORD cchName = MAX_PATH;<BR>            hr = pqa-&gt;GetString(0, ASSOCSTR_FRIENDLYAPPNAME, NULL, wszName, &amp;cchName);<BR>            if (SUCCEEDED(hr)) {<BR>                VARIANTARG rgvarg[2] = { 0 };<BR>                V_VT(&amp;rgvarg[0]) = VT_BSTR;<BR>                V_BSTR(&amp;rgvarg[0]) = SysAllocString(wszName);<BR>                if (V_BSTR(&amp;rgvarg[0])) {<BR>                    DISPPARAMS dp;<BR>                    LONG lUnique = InterlockedIncrement(&amp;lCounter);<BR>                    V_VT(&amp;rgvarg[1]) = VT_I4;<BR>                    V_I4(&amp;rgvarg[1]) = fUnique ? lUnique : 0;<BR>                    dp.rgvarg = rgvarg;<BR>                    dp.cArgs = 2;<BR>                    dp.rgdispidNamedArgs = NULL;<BR>                    dp.cNamedArgs = 0;<BR>                    hr = pdisp-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, &amp;dp, NULL, NULL, NULL);<BR>                    VariantClear(&amp;rgvarg[0]);<BR>                    VariantClear(&amp;rgvarg[1]);<BR>                } else {<BR>                    hr = E_OUTOFMEMORY;<BR>                }<BR>            }<BR>        }<BR>        pqa-&gt;Release();<BR>    }<BR>    return hr;<BR>}<BR><BR></nobr></P>
<P>We'll go through this function and the equivalent assembly line by line.</P>
<P>When entered, the function's parameters are stored as follows:</P><B></B><UL type="disc">
<LI><b>rcx</b> = <i>pdisp</i>.</LI>
<LI><b>rdx</b> = <i>dispid</i>.</LI>
<LI><b>r8</b> = <i>fUnique</i>.</LI>
<LI><b>r9</b> = <i>pszExe</i>.</LI>
</UL>
<P></P>
<P>Recall that the first four parameters are passed in registers. Since this function has only four registers, none are passed on the stack.</P>
<P>The assembly begins as follows:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>Meaningless:<BR>010010e0 push    rbx                    ; save<BR>010010e1 push    rsi                    ; save<BR>010010e2 push    rdi                    ; save<BR>010010e3 push    r12d                   ; save<BR>010010e5 push    r13d                   ; save<BR>010010e7 push    r14d                   ; save<BR>010010e9 push    r15d                   ; save<BR>010010eb sub     rsp,0x2c0              ; reserve stack<BR>010010f2 mov     rbx,r9                 ; rbx = pszExe<BR>010010f5 mov     r12d,r8d               ; r12 = fUnique (zero-extend)<BR>010010f8 mov     r13d,edx               ; r13 = dispid  (zero-extend)<BR>010010fb mov     rsi,rcx                ; rsi = pdisp<BR><BR></nobr></P>
<P>The function begins by saving nonvolatile registers, and then reserving stack space for local variables.  It then saves parameters in nonvolatile registers.  Note that the destination of the middle two <b>mov</b> instructions is a 32-bit register, so they are implicitly zero-extended to 64 bits.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    IQueryAssociations *pqa;<BR>    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_IQueryAssociations, (void**)&amp;pqa);<BR><BR></nobr></P>
<P>The first parameter to <b>AssocCreate</b> is a 128-bit CLSID passed by value. Since this doesn't fit in a 64-bit register, the CLSID is copied to the stack, and a pointer to the stack location is passed instead.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>010010fe movdqu  xmm0,oword ptr [CLSID_QueryAssociations (01001060)]<BR>01001106 movdqu  oword ptr [rsp+0x60],xmm0  ; temp buffer for first parameter<BR>0100110c lea     r8,[rsp+0x58]          ; arg3 = &amp;pqa<BR>01001111 lea rdx,[IID_IQueryAssociations (01001070)] ; arg2 = &amp;IID_IQueryAssociations<BR>01001118 lea     rcx,[rsp+0x60]         ; arg1 = &amp;temporary<BR>0100111d call qword ptr [_imp_AssocCreate (01001028)] ; call<BR><BR></nobr></P>
<P>The <b>movdqu</b> instruction transfers 128-bits values to and from <b>xmm</b><i>n</i> registers. In this instance, the assembly code uses it to copy the CLSID to the stack.  The pointer to the CLSID is passed in <b>r8</b>.  The other two arguments are passed in <b>rcx</b> and <b>rdx</b>.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    if (SUCCEEDED(hr)) {<BR><BR>01001123 test    eax,eax<BR>01001125 jl      ReturnEAX (01001281)<BR><BR></nobr></P>
<P>The code checks to see if the return value is a success.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        hr = pqa-&gt;Init(ASSOCF_INIT_BYEXENAME, pszExe, NULL, NULL);<BR><BR>0100112b mov     rcx,[rsp+0x58]         ; arg1 = pqa<BR>01001130 mov     rax,[rcx]              ; rax = pqa.vtbl<BR>01001133 xor     r14d,r14d              ; r14 = 0<BR>01001136 mov     [rsp+0x20],r14         ; arg5 = 0<BR>0100113b xor     r9d,r9d                ; arg4 = 0<BR>0100113e mov     r8,rbx                 ; arg3 = pszExe<BR>01001141 mov     r15d,0x2               ; r15 = 2 (for later)<BR>01001147 mov     edx,r15d               ; arg2 = 2 (ASSOCF_INIT_BY_EXENAME)<BR>0100114a call    qword ptr [rax+0x18]   ; call Init method<BR><BR></nobr></P>
<P>This is an indirect function call using a C++ vtable. The <b>this</b> pointer is passed in <b>rcx</b> as the first parameter.  The first three parameters are passed in registers, while the final parameter is passed on the stack.  The function reserves 16 bytes for the parameters passed in registers, so the fifth parameter begins at <b>rsp</b>+0x20.  </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if (SUCCEEDED(hr)) {<BR><BR>0100114d mov     ebx,eax                ; ebx = hr<BR>0100114f test    ebx,ebx                ; FAILED?<BR>01001151 jl      ReleasePQA (01001274)  ; jump if so<BR><BR></nobr></P>
<P>The assembly-language code saves the result in <b>ebx</b>, and checks to see if it's a success code.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            WCHAR wszName[MAX_PATH];<BR>            DWORD cchName = MAX_PATH;<BR>            hr = pqa-&gt;GetString(0, ASSOCSTR_FRIENDLYAPPNAME, NULL, wszName, &amp;cchName);<BR>            if (SUCCEEDED(hr)) {<BR><BR>01001157 mov     dword ptr [rsp+0x50],0x104 ; cchName = MAX_PATH<BR>0100115f mov     rcx,[rsp+0x58]         ; arg1 = pqa<BR>01001164 mov     rax,[rcx]              ; rax = pqa.vtbl<BR>01001167 lea     rdx,[rsp+0x50]         ; rdx = &amp;cchName<BR>0100116c mov     [rsp+0x28],rdx         ; arg6 = cchName<BR>01001171 lea     rdx,[rsp+0xb0]         ; rdx = &amp;wszName[0]<BR>01001179 mov     [rsp+0x20],rdx         ; arg5 = &amp;wszName[0]<BR>0100117e xor     r9d,r9d                ; arg4 = 0<BR>01001181 mov     r8d,0x4                ; arg3 = 4 (ASSOCSTR_FRIENDLYNAME)<BR>01001187 xor     edx,edx                ; arg2 = 0<BR>01001189 call    qword ptr [rax+0x20]   ; call GetString method<BR>0100118c mov     ebx,eax                ; ebx = hr<BR>0100118e test    ebx,ebx                ; FAILED?<BR>01001190 jl      ReleasePQA (01001274)  ; jump if so<BR><BR></nobr></P>
<P>Once again, we set up the parameters and call a function, then test the return value for success.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                VARIANTARG rgvarg[2] = { 0 };<BR><BR>01001196 lea     rdi,[rsp+0x82]         ; rdi = &amp;rgvarg<BR>0100119e xor     eax,eax                ; rax = 0<BR>010011a0 mov     ecx,0x2e               ; rcx = sizeof(rgvarg)<BR>010011a5 rep     stosb                  ; Zero it out<BR><BR></nobr></P>
<P>The idiomatic method for zeroing out a buffer on x64 is the same as x86.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                V_VT(&amp;rgvarg[0]) = VT_BSTR;<BR>                V_BSTR(&amp;rgvarg[0]) = SysAllocString(wszName);<BR>                if (V_BSTR(&amp;rgvarg[0])) {<BR><BR>010011a7 mov     word ptr [rsp+0x80],0x8 ; V_VT(&amp;rgvarg[0]) = VT_BSTR<BR>010011b1 lea     rcx,[rsp+0xb0]         ; arg1 = &amp;wszName[0]<BR>010011b9 call    qword ptr [_imp_SysAllocString (01001010)] ; call<BR>010011bf mov     [rsp+0x88],rax         ; V_BSTR(&amp;rgvarg[0]) = result<BR>010011c7 test    rax,rax                ; anything allocated?<BR>010011ca je      OutOfMemory (0100126f) ; jump if failed<BR><BR>                    DISPPARAMS dp;<BR>                    LONG lUnique = InterlockedIncrement(&amp;lCounter);<BR><BR>010011d0 lea     rax,[lCounter (01002000)]<BR>010011d7 mov     ecx,0x1<BR>010011dc lock    xadd [rax],ecx             ; interlocked exchange and add<BR>010011e0 add     ecx,0x1<BR><BR></nobr></P>
<P><b>InterlockedIncrement</b> compiles directly to machine code.  The <b>lock</b> <b>xadd</b> instruction performs an atomic exchange and add.  The final result is stored in <b>ecx</b>.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                    V_VT(&amp;rgvarg[1]) = VT_I4;<BR>                    V_I4(&amp;rgvarg[1]) = fUnique ? lUnique : 0;<BR><BR>010011e3 mov     word ptr [rsp+0x98],0x3    ; V_VT(&amp;rgvarg[1]) = VT_I4;<BR>010011ed mov     eax,r14d                   ; rax = 0 (r14d is still zero)<BR>010011f0 test    r12d,r12d                  ; fUnique set?<BR>010011f3 cmovne  eax,ecx                    ; if so, then set rax=lCounter<BR>010011f6 mov     [rsp+0xa0],eax             ; V_I4(&amp;rgvarg[1]) = ...<BR><BR></nobr></P>
<P>Since x64 supports the <b>cmov</b> instruction, the <b>?:</b> construct can be compiled without using a jump.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                    dp.rgvarg = rgvarg;<BR>                    dp.cArgs = 2;<BR>                    dp.rgdispidNamedArgs = NULL;<BR>                    dp.cNamedArgs = 0;<BR><BR>010011fd lea     rax,[rsp+0x80]             ; rax = &amp;rgvarg[0]<BR>01001205 mov     [rsp+0x60],rax             ; dp.rgvarg = rgvarg<BR>0100120a mov     [rsp+0x70],r15d            ; dp.cArgs = 2 (r15 is still 2)<BR>0100120f mov     [rsp+0x68],r14             ; dp.rgdispidNamedArgs = NULL<BR>01001214 mov     [rsp+0x74],r14d            ; dp.cNamedArgs = 0<BR><BR></nobr></P>
<P>This code initializes the rest of the members of DISPPARAMS.  Note that the compiler reuses the space on the stack previously used by the CLSID.  </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                    hr = pdisp-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, &amp;dp, NULL, NULL, NULL);<BR><BR>01001219 mov     rax,[rsi]                  ; rax = pdisp.vtbl<BR>0100121c mov     [rsp+0x40],r14             ; arg9 = 0<BR>01001221 mov     [rsp+0x38],r14             ; arg8 = 0<BR>01001226 mov     [rsp+0x30],r14             ; arg7 = 0<BR>0100122b lea     rcx,[rsp+0x60]             ; rcx = &amp;dp<BR>01001230 mov     [rsp+0x28],rcx             ; arg6 = &amp;dp<BR>01001235 mov     word ptr [rsp+0x20],0x1    ; arg5 = 1 (DISPATCH_METHOD)<BR>0100123c xor     r9d,r9d                    ; arg4 = 0<BR>0100123f lea     r8,[GUID_NULL (01001080)]  ; arg3 = &amp;IID_NULL<BR>01001246 mov     edx,r13d                   ; arg2 = dispid<BR>01001249 mov     rcx,rsi                    ; arg1 = pdisp<BR>0100124c call    qword ptr [rax+0x30]       ; call Invoke method<BR>0100124f mov     ebx,eax                    ; hr = result<BR><BR></nobr></P>
<P>The code then sets up the parameters and calls the <b>Invoke</b> method.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                    VariantClear(&amp;rgvarg[0]);<BR>                    VariantClear(&amp;rgvarg[1]);<BR><BR>01001251 lea     rcx,[rsp+0x80]             ; arg1 = &amp;rgvarg[0]<BR>01001259 call    qword ptr [_imp_VariantClear (01001018)]<BR>0100125f lea     rcx,[rsp+0x98]             ; arg1 = &amp;rgvarg[1]<BR>01001267 call    qword ptr [_imp_VariantClear (01001018)]<BR>0100126d jmp     ReleasePQA (01001274)<BR><BR></nobr></P>
<P>The code finishes up the current branch of the conditional, and skips over the <b>else</b> branch.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                } else {<BR>                    hr = E_OUTOFMEMORY;<BR>                }<BR>            }<BR><BR>OutOfMemory:<BR>0100126f mov     ebx,0x8007000e             ; hr = E_OUTOFMEMORY<BR>        pqa-&gt;Release();<BR>ReleasePQA:<BR>01001274 mov     rcx,[rsp+0x58]             ; arg1 = pqa<BR>01001279 mov     rax,[rcx]                  ; rax = pqa.vtbl<BR>0100127c call    qword ptr [rax+0x10]       ; release<BR><BR></nobr></P>
<P>The <b>else</b> branch.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    return hr;<BR>}<BR><BR>0100127f mov     eax,ebx                    ; rax = hr (for return value)<BR>ReturnEAX:<BR>01001281 add     rsp,0x2c0                  ; clean up the stack<BR>01001288 pop     r15d                       ; restore<BR>0100128a pop     r14d                       ; restore<BR>0100128c pop     r13d                       ; restore<BR>0100128e pop     r12d                       ; restore<BR>01001290 pop     rdi                        ; restore<BR>01001291 pop     rsi                        ; restore<BR>01001292 pop     rbx                        ; restore<BR>01001293 ret                                ; return (do not pop arguments)<BR><BR></nobr></P>
<P>The return value is stored in <b>rax</b>, and then the non-volatile registers are restored before returning.</P>
<P></P>
<P></P>
<DIV style="display:yes"></DIV>
<DIV CLASS="footer"><br><A href="dbglegal.htm">© 2009 Microsoft Corporation</A><br><A href="mailto:windbgfb@microsoft.com?subject=documentation feedback [Debugger]: Annotated x64 Disassembly RELEASE: (December 09, 2009)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AThe WDK team uses the feedback submitted to improve the WDK documentation. We do not use your e-mail address for any other purpose. We will remove your e-mail address from our system after the issue you are reporting has been resolved. While we are working to resolve this issue, we may send you an e-mail message to request more information about your feedback. After the issues have been addressed, we may send you an e-mail message to let you know that your feedback has been addressed.%0A%0AFor more information about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx.
              ">Send feedback on this topic</A><br>Debugging Tools for Windows<br>December 09, 2009<br></DIV>
</Body>
</HTML>
