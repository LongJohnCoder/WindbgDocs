<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/MSHelp">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>Annotated x86 Disassembly</TITLE>
<META NAME="ms.locale" content="en-us">
<META NAME="DESCRIPTION" CONTENT="Debugger, Debugger, Design Guide, Annotated x86 Disassembly"><xml><MSHelp:Keyword Index="A" Term="t09_arch_x86_b2959e7f-0c75-49de-b2eb-b615795fe95d.xml"/>
<META NAME="MS-HKWD" CONTENT="x86 processor, annotated disassembly">
<META NAME="MS-HKWD" CONTENT="x86 processor, assembly code">
<META NAME="MS-HKWD" CONTENT="x86 processor, source code"></xml><LINK REL="stylesheet" type="text/css" href="backsdk4.css"><SCRIPT src="langref.js"></SCRIPT><style>dd {margin-bottom:0em; margin-left:1.9em; }</style>
<style>.divclass {behavior:url(#default#savehistory);}</style>
<META NAME="save" CONTENT="history">
</HEAD>
<Body topmargin="0">
<DIV STYLE="display:none;"></DIV>
<DIV STYLE="display:none;"></DIV>
<TABLE CLASS="buttonbarshade" CELLSPACING="0" border="0"><TR><TD NOWRAP="true"> </TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING="0">
<TR ID="hdr">
<TD NOWRAP="true" CLASS="runninghead">Debugging Tools for Windows</TD>
</TR>
</TABLE>
<H1><A NAME="t09_arch_x86_b2959e7f-0c75-49de-b2eb-b615795fe95d.xml"></A>Annotated x86 Disassembly</H1>
<P>The following section will walk you through a disassembly example.</P>
<P></P>
<P></P>
<H3><A NAME="592b23d3-8e85-48cb-9387-b8ab214cd6fc"></A>Source Code</H3>
<P>The following is the code for the function that will be analyzed.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>HRESULT CUserView::CloseView(void)<BR>{<BR>    if (m_fDestroyed) return S_OK;<BR><BR>    BOOL fViewObjectChanged = FALSE;<BR>    ReleaseAndNull(&amp;m_pdtgt);<BR><BR>    if (m_psv) {<BR>        m_psb-&gt;EnableModelessSB(FALSE);<BR>        if(m_pws) m_pws-&gt;ViewReleased();<BR><BR>        IShellView* psv;<BR><BR>        HWND hwndCapture = GetCapture();<BR>        if (hwndCapture &amp;&amp; hwndCapture == m_hwnd) {<BR>            SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);<BR>        }<BR><BR>        m_fHandsOff = TRUE;<BR>        m_fRecursing = TRUE;<BR>        NotifyClients(m_psv, NOTIFY_CLOSING);<BR>        m_fRecursing = FALSE;<BR><BR>        m_psv-&gt;UIActivate(SVUIA_DEACTIVATE);<BR><BR>        psv = m_psv;<BR>        m_psv = NULL;<BR><BR>        ReleaseAndNull(&amp;_pctView);<BR><BR>        if (m_pvo) {<BR>            IAdviseSink *pSink;<BR>            if (SUCCEEDED(m_pvo-&gt;GetAdvise(NULL, NULL, &amp;pSink)) &amp;&amp; pSink) {<BR>                if (pSink == (IAdviseSink *)this)<BR>                    m_pvo-&gt;SetAdvise(0, 0, NULL);<BR>                pSink-&gt;Release();<BR>            }<BR><BR>            fViewObjectChanged = TRUE;<BR>            ReleaseAndNull(&amp;m_pvo);<BR>        }<BR><BR>        if (psv) {<BR>            psv-&gt;SaveViewState();<BR>            psv-&gt;DestroyViewWindow();<BR>            psv-&gt;Release();<BR>        }<BR><BR>        m_hwndView = NULL;<BR>        m_fHandsOff = FALSE;<BR><BR>        if (m_pcache) {<BR>            GlobalFree(m_pcache);<BR>            m_pcache = NULL;<BR>        }<BR><BR>        m_psb-&gt;EnableModelessSB(TRUE);<BR><BR>        CancelPendingActions();<BR>    }<BR><BR>    ReleaseAndNull(&amp;_psf);<BR><BR>    if (fViewObjectChanged)<BR>        NotifyViewClients(DVASPECT_CONTENT, -1);<BR><BR>    if (m_pszTitle) {<BR>        LocalFree(m_pszTitle);<BR>        m_pszTitle = NULL;<BR>    }<BR><BR>    SetRect(&amp;m_rcBounds, 0, 0, 0, 0);<BR>    return S_OK;<BR>}<BR><BR></nobr></P>
<H3><A NAME="fc131dd8-8ea0-471e-8dd6-13dce3b00b59"></A>Assembly Code</H3>
<P>This section contains the annotated disassembly example.</P>
<P>Functions which use the <b>ebp</b> register as a frame pointer start out as follows:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>HRESULT CUserView::CloseView(void)<BR>SAMPLE!CUserView__CloseView:<BR>71517134 55               push    ebp<BR>71517135 8bec             mov     ebp,esp<BR><BR></nobr></P>
<P>This sets up the frame so the function can access its parameters as positive offsets from <b>ebp</b>, and local variables as negative offsets.</P>
<P>This is a method on a private COM interface, so the calling convention is <b>__stdcall</b>. This means that parameters are pushed right to left (in this case, there are none), the "this" pointer is pushed, and then the function is called. Thus, upon entry into the function, the stack looks like this:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>[esp+0] = return address<BR>[esp+4] = this<BR><BR></nobr></P>
<P>After the two preceding instructions, the parameters are accessible as:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>[ebp+0] = previous ebp pushed on stack<BR>[ebp+4] = return address<BR>[ebp+8] = this<BR><BR></nobr></P>
<P><i>For a function that uses <B>ebp</B> as a frame pointer, the first pushed parameter is accessible at [<B>ebp</B>+8]; subsequent parameters are accessible at consecutive higher DWORD addresses.</i></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>71517137 51               push    ecx<BR>71517138 51               push    ecx<BR><BR></nobr></P>
<P>This function requires only two local stack variables, so a <b>sub</b> <b>esp</b>, 8 instruction. The pushed values are then available as [<b>ebp</b>-4] and [<b>ebp</b>-8].</P>
<P><i>For a function that uses <B>ebp</B> as a frame pointer, stack local variables are accessible at negative offsets from the <B>ebp</B> register.</i></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>71517139 56               push    esi<BR><BR></nobr></P>
<P>Now the compiler saves the registers that are required to be preserved across function calls. Actually, it saves them in bits and pieces, interleaved with the first line of actual code.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>7151713a 8b7508           mov     esi,[ebp+0x8]     ; esi = this<BR>7151713d 57               push    edi               ; save another registers<BR><BR></nobr></P>
<P>It so happens that CloseView is a method on ViewState, which is at offset 12 in the underlying object. Consequently, <b>this</b> is a pointer to a ViewState class, although when there is possible confusion with another base class, it will be more carefully specified as (ViewState*)<b>this</b>.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    if (m_fDestroyed)<BR>7151713e 33ff             xor     edi,edi           ; edi = 0<BR><BR></nobr></P>
<P><i>XORing a register with itself is a standard way of zeroing it out.</i></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>71517140 39beac000000     cmp     [esi+0xac],edi    ; this-&gt;m_fDestroyed == 0?<BR>71517146 7407             jz      NotDestroyed (7151714f)  ; jump if equal<BR><BR></nobr></P>
<P>The <b>cmp </b>instruction compares two values (by subtracting them). The <b>jz</b> instruction checks if the result is zero, indicating that the two compared values are equal.</P>
<P><i>The cmp instruction compares two values; a subsequent j instruction jumps based on the result of the comparison.</i></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    return S_OK;<BR>71517148 33c0             xor     eax,eax           ; eax = 0 = S_OK<BR>7151714a e972010000       jmp     ReturnNoEBX (715172c1) ; return, do not pop EBX<BR><BR></nobr></P>
<P>The compiler delayed saving the EBX register until later in the function, so if the program is going to "early-out" on this test, then the exit path needs to be the one that does not restore EBX.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    BOOL fViewObjectChanged = FALSE;<BR>    ReleaseAndNull(&amp;m_pdtgt);<BR><BR></nobr></P>
<P>The execution of these two lines of code is interleaved, so pay attention.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>NotDestroyed:<BR>7151714f 8d86c0000000     lea     eax,[esi+0xc0]    ; eax = &amp;m_pdtgt<BR><BR></nobr></P>
<P>The <b>lea</b> instruction computes the effect address of a memory access and stores it in the destination. The actual memory address is not dereferenced.</P>
<P><i>The lea instruction takes the address of a variable.</i></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>71517155 53               push    ebx<BR><BR></nobr></P>
<P></P>
<P>You should save that EBX register before it is damaged.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>71517156 8b1d10195071     mov ebx,[_imp__ReleaseAndNull]<BR><BR></nobr></P>
<P>Because you will be calling <b>ReleaseAndNull</b> frequently, it is a good idea to cache its address in EBX.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>7151715c 50               push    eax               ; parameter to ReleaseAndNull<BR>7151715d 897dfc           mov     [ebp-0x4],edi     ; fViewObjectChanged = FALSE<BR>71517160 ffd3             call    ebx               ; call ReleaseAndNull<BR>    if (m_psv) {<BR>71517162 397e74           cmp     [esi+0x74],edi    ; this-&gt;m_psv == 0?<BR>71517165 0f8411010000     je      No_Psv (7151727c) ; jump if zero<BR><BR></nobr></P>
<P>Remember that you zeroed out the EDI register a while back and that EDI is a register preserved across function calls (so the call to <b>ReleaseAndNull</b> did not change it). Therefore, it still holds the value zero and you can use it to quickly test for zero.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_psb-&gt;EnableModelessSB(FALSE);<BR>7151716b 8b4638           mov     eax,[esi+0x38]    ; eax = this-&gt;m_psb<BR>7151716e 57               push    edi               ; FALSE<BR>7151716f 50               push    eax               ; "this" for callee<BR>71517170 8b08             mov     ecx,[eax]         ; ecx = m_psb-&gt;lpVtbl<BR>71517172 ff5124           call    [ecx+0x24]        ; __stdcall EnableModelessSB<BR><BR></nobr></P>
<P><i>The above pattern is a telltale sign of a COM method call.</i></P>
<P>COM method calls are pretty popular, so it is a good idea to learn to recognize them. In particular, you should be able to recognize the three IUnknown methods directly from their Vtable offsets: QueryInterface=0, AddRef=4, and Release=8.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if(m_pws) m_pws-&gt;ViewReleased();<BR>71517175 8b8614010000     mov     eax,[esi+0x114]   ; eax = this-&gt;m_pws<BR>7151717b 3bc7             cmp     eax,edi           ; eax == 0?<BR>7151717d 7406             jz      NoWS (71517185) ; if so, then jump<BR>7151717f 8b08             mov     ecx,[eax]         ; ecx = m_pws-&gt;lpVtbl<BR>71517181 50               push    eax               ; "this" for callee<BR>71517182 ff510c           call    [ecx+0xc]         ; __stdcall ViewReleased<BR>NoWS:<BR>        HWND hwndCapture = GetCapture();<BR>71517185 ff15e01a5071    call [_imp__GetCapture]    ; call GetCapture<BR><BR></nobr></P>
<P>Indirect calls through globals is how function imports are implemented in Microsoft Win32. The loader fixes up the globals to point to the actual address of the target. This is a handy way to get your bearings when you are investigating a crashed machine. Look for the calls to imported functions and in the target. You will usually have the name of some imported function, which you can use to determine where you are in the source code.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if (hwndCapture &amp;&amp; hwndCapture == m_hwnd) {<BR>            SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);<BR>        }<BR>7151718b 3bc7             cmp     eax,edi           ; hwndCapture == 0?<BR>7151718d 7412             jz      No_Capture (715171a1) ; jump if zero<BR><BR></nobr></P>
<P><i>The function return value is placed in the EAX register.</i></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>7151718f 8b4e44           mov     ecx,[esi+0x44]    ; ecx = this-&gt;m_hwnd<BR>71517192 3bc1             cmp     eax,ecx           ; hwndCapture = ecx?<BR>71517194 750b             jnz     No_Capture (715171a1) ; jump if not<BR><BR>71517196 57               push    edi               ; 0<BR>71517197 57               push    edi               ; 0<BR>71517198 6a1f             push    0x1f              ; WM_CANCELMODE<BR>7151719a 51               push    ecx               ; hwndCapture<BR>7151719b ff1518195071     call    [_imp__SendMessageW] ; SendMessage<BR>No_Capture:<BR>        m_fHandsOff = TRUE;<BR>        m_fRecursing = TRUE;<BR>715171a1 66818e0c0100000180 or    word ptr [esi+0x10c],0x8001 ; set both flags at once<BR><BR></nobr></P>
<P></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        NotifyClients(m_psv, NOTIFY_CLOSING);<BR>715171aa 8b4e20           mov     ecx,[esi+0x20]    ; ecx = (CNotifySource*)this.vtbl<BR>715171ad 6a04             push    0x4               ; NOTIFY_CLOSING<BR>715171af 8d4620           lea     eax,[esi+0x20]    ; eax = (CNotifySource*)this<BR>715171b2 ff7674           push    [esi+0x74]        ; m_psv<BR>715171b5 50               push    eax               ; "this" for callee<BR>715171b6 ff510c           call    [ecx+0xc]         ; __stdcall NotifyClients<BR><BR></nobr></P>
<P>Notice how you had to change your "this" pointer when calling a method on a different base class from your own.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_fRecursing = FALSE;<BR>715171b9 80a60d0100007f   and     byte ptr [esi+0x10d],0x7f<BR>        m_psv-&gt;UIActivate(SVUIA_DEACTIVATE);<BR>715171c0 8b4674           mov     eax,[esi+0x74]    ; eax = m_psv<BR>715171c3 57               push    edi               ; SVUIA_DEACTIVATE = 0<BR>715171c4 50               push    eax               ; "this" for callee<BR>715171c5 8b08             mov     ecx,[eax]         ; ecx = vtbl<BR>715171c7 ff511c           call    [ecx+0x1c]        ; __stdcall UIActivate<BR>        psv = m_psv;<BR>        m_psv = NULL;<BR>715171ca 8b4674           mov     eax,[esi+0x74]    ; eax = m_psv<BR>715171cd 897e74           mov     [esi+0x74],edi    ; m_psv = NULL<BR>715171d0 8945f8           mov     [ebp-0x8],eax     ; psv = eax<BR><BR></nobr></P>
<P>The first local variable is <b>psv</b>.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        ReleaseAndNull(&amp;_pctView);<BR>715171d3 8d466c           lea     eax,[esi+0x6c]    ; eax = &amp;_pctView<BR>715171d6 50               push    eax               ; parameter<BR>715171d7 ffd3             call    ebx               ; call ReleaseAndNull<BR>        if (m_pvo) {<BR>715171d9 8b86a8000000     mov     eax,[esi+0xa8]    ; eax = m_pvo<BR>715171df 8dbea8000000     lea     edi,[esi+0xa8]    ; edi = &amp;m_pvo<BR>715171e5 85c0             test    eax,eax           ; eax == 0?<BR>715171e7 7448             jz      No_Pvo (71517231) ; jump if zero<BR><BR></nobr></P>
<P>Note that the compiler speculatively prepared the address of the <i>m_pvo</i> member, because you are going to use it frequently for a while. Thus, having the address handy will result in smaller code.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            if (SUCCEEDED(m_pvo-&gt;GetAdvise(NULL, NULL, &amp;pSink)) &amp;&amp; pSink) {<BR>715171e9 8b08             mov     ecx,[eax]         ; ecx = m_pvo-&gt;lpVtbl<BR>715171eb 8d5508           lea     edx,[ebp+0x8]     ; edx = &amp;pSink<BR>715171ee 52               push    edx               ; parameter<BR>715171ef 6a00             push    0x0               ; NULL<BR>715171f1 6a00             push    0x0               ; NULL<BR>715171f3 50               push    eax               ; "this" for callee<BR>715171f4 ff5120           call    [ecx+0x20]        ; __stdcall GetAdvise<BR>715171f7 85c0             test    eax,eax           ; test bits of eax<BR>715171f9 7c2c             jl      No_Advise (71517227) ; jump if less than zero<BR>715171fb 33c9             xor     ecx,ecx           ; ecx = 0<BR>715171fd 394d08           cmp     [ebp+0x8],ecx     ; _pSink == ecx?<BR>71517200 7425             jz      No_Advise (71517227)<BR><BR></nobr></P>
<P>Notice that the compiler concluded that the incoming "this" parameter was not required (because it long ago stashed that into the ESI register). Thus, it reused the memory as the local variable pSink.</P>
<P>If the function uses an EBP frame, then incoming parameters arrive at positive offsets from EBP and local variables are placed at negative offsets. But, as in this case, the compiler is free to reuse that memory for any purpose.</P>
<P>If you are paying close attention, you will see that the compiler could have optimized this code a little better. It could have delayed the <b>lea edi, [esi+0xa8]</b> instruction until after the two <b>push 0x0</b> instructions, replacing them with <b>push edi</b>. This would have saved 2 bytes.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                if (pSink == (IAdviseSink *)this)<BR><BR></nobr></P>
<P>These next several lines are to compensate for the fact that in C++, (IAdviseSink *)NULL must still be NULL. So if your "this" is really "(ViewState*)NULL", then the result of the cast should be NULL and not the distance between IAdviseSink and IBrowserService.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>71517202 8d46ec           lea     eax,[esi-0x14]    ; eax = -(IAdviseSink*)this<BR>71517205 8d5614           lea     edx,[esi+0x14]    ; edx = (IAdviseSink*)this<BR>71517208 f7d8             neg     eax               ; eax = -eax (sets carry if != 0)<BR>7151720a 1bc0             sbb     eax,eax           ; eax = eax - eax - carry<BR>7151720c 23c2             and     eax,edx           ; eax = NULL or edx<BR><BR></nobr></P>
<P>Although the Pentium has a conditional move instruction, the base i386 architecture does not, so the compiler uses specific techniques to simulate a conditional move instruction without taking any jumps.</P>
<P>The general pattern for a conditional evaluation is the following:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        neg     r<BR>        sbb     r, r<BR>        and     r, (val1 - val2)<BR>        add     r, val2<BR><BR></nobr></P>
<P>The <b>neg r</b> sets the carry flag if <b>r</b> is nonzero, because <b>neg</b> negates the value by subtracting from zero. And, subtracting from zero will generate a borrow (set the carry) if you subtract a nonzero value. It also damages the value in the <b>r</b> register, but that is acceptable because you are about to overwrite it anyway.</P>
<P>Next, the <b>sbb r, r</b> instruction subtracts a value from itself, which always results in zero. However, it also subtracts the carry (borrow) bit, so the net result is to set <b>r</b> to zero or -1, depending on whether the carry was clear or set, respectively.</P>
<P>Therefore, <b>sbb r, r</b> sets <b>r</b> to zero if the original value of <b>r</b> was zero, or to -1 if the original value was nonzero.</P>
<P>The third instruction performs a mask. Because the <b>r</b> register is zero or -1, "this" serves either to leave <b>r</b> zero or to change <b>r</b> from -1 to <b>(val1 - val1)</b>, in that ANDing any value with -1 leaves the original value.</P>
<P>Therefore, the result of "and r, (val1 - val1)" is to set r to zero if the original value of r was zero, or to "(val1 - val2)" if the original value of r was nonzero.</P>
<P>Finally, you add <b>val2</b> to <b>r</b>, resulting in <b>val2</b> or <b>(val1 - val2) + val2 = val1</b>.</P>
<P>Thus, the ultimate result of this series of instructions is to set <b>r</b> to <b>val2</b> if it was originally zero or to <b>val1</b> if it was nonzero. This is the assembly equivalent of <i>r = r ? val1 : val2.</i></P>
<P>In this particular instance, you can see that <b>val2 = 0</b> and <b>val1 = (IAdviseSink*)this</b>. (Notice that the compiler elided the final <b>add eax, 0</b> instruction because it has no effect.)</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>7151720e 394508           cmp     [ebp+0x8],eax ; pSink == (IAdviseSink*)this?<BR>71517211 750b             jnz     No_SetAdvise (7151721e) ; jump if not equal<BR><BR></nobr></P>
<P>Earlier in this section,  you set EDI to the address of the <i>m_pvo</i> member. You are going to be using it now. You also zeroed out the ECX register earlier.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                    m_pvo-&gt;SetAdvise(0, 0, NULL);<BR>71517213 8b07             mov     eax,[edi]         ; eax = m_pvo<BR>71517215 51               push    ecx               ; NULL<BR>71517216 51               push    ecx               ; 0<BR>71517217 51               push    ecx               ; 0<BR>71517218 8b10             mov     edx,[eax]         ; edx = m_pvo-&gt;lpVtbl<BR>7151721a 50               push    eax               ; "this" for callee<BR>7151721b ff521c           call    [edx+0x1c]        ; __stdcall SetAdvise<BR>No_SetAdvise:<BR>                pSink-&gt;Release();<BR>7151721e 8b4508           mov     eax,[ebp+0x8]     ; eax = pSink<BR>71517221 50               push    eax               ; "this" for callee<BR>71517222 8b08             mov     ecx,[eax]         ; ecx = pSink-&gt;lpVtbl<BR>71517224 ff5108           call    [ecx+0x8]         ; __stdcall Release<BR>No_Advise:<BR><BR></nobr></P>
<P>All these COM method calls should look very familiar.</P>
<P>The evaluation of the next two statements is interleaved. Do not forget that EBX contains the address of <b>ReleaseAndNull</b>.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            fViewObjectChanged = TRUE;<BR>            ReleaseAndNull(&amp;m_pvo);<BR>71517227 57               push    edi               ; &amp;m_pvo<BR>71517228 c745fc01000000   mov     dword ptr [ebp-0x4],0x1 ; fViewObjectChanged = TRUE<BR>7151722f ffd3             call    ebx               ; call ReleaseAndNull<BR>No_Pvo:<BR>        if (psv) {<BR>71517231 8b7df8           mov     edi,[ebp-0x8]     ; edi = psv<BR>71517234 85ff             test    edi,edi           ; edi == 0?<BR>71517236 7412             jz      No_Psv2 (7151724a) ; jump if zero<BR>            psv-&gt;SaveViewState();<BR>71517238 8b07             mov     eax,[edi]         ; eax = psv-&gt;lpVtbl<BR>7151723a 57               push    edi               ; "this" for callee<BR>7151723b ff5034           call    [eax+0x34]        ; __stdcall SaveViewState<BR><BR></nobr></P>
<P>Here are more COM method calls.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            psv-&gt;DestroyViewWindow();<BR>7151723e 8b07             mov     eax,[edi]         ; eax = psv-&gt;lpVtbl<BR>71517240 57               push    edi               ; "this" for callee<BR>71517241 ff5028           call    [eax+0x28]        ; __stdcall DestroyViewWindow<BR>            psv-&gt;Release();<BR>71517244 8b07             mov     eax,[edi]         ; eax = psv-&gt;lpVtbl<BR>71517246 57               push    edi               ; "this" for callee<BR>71517247 ff5008           call    [eax+0x8]         ; __stdcall Release<BR>No_Psv2:<BR>        m_hwndView = NULL;<BR>7151724a 83667c00         and     dword ptr [esi+0x7c],0x0 ; m_hwndView = 0<BR><BR></nobr></P>
<P>ANDing a memory location with zero is the same as setting it to zero, because anything AND zero is zero. The compiler uses this form because, even though it is slower, it is much shorter than the equivalent <b>mov</b> instruction. (This code was optimized for size, not speed.)</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_fHandsOff = FALSE;<BR>7151724e 83a60c010000fe   and     dword ptr [esi+0x10c],0xfe<BR>        if (m_pcache) {<BR>71517255 8b4670           mov     eax,[esi+0x70]    ; eax = m_pcache<BR>71517258 85c0             test    eax,eax           ; eax == 0?<BR>7151725a 740b             jz      No_Cache (71517267) ; jump if zero<BR>            GlobalFree(m_pcache);<BR>7151725c 50               push    eax               ; m_pcache<BR>7151725d ff15b4135071     call    [_imp__GlobalFree]    ; call GlobalFree<BR>            m_pcache = NULL;<BR>71517263 83667000         and     dword ptr [esi+0x70],0x0 ; m_pcache = 0<BR>No_Cache:<BR>        m_psb-&gt;EnableModelessSB(TRUE);<BR>71517267 8b4638           mov     eax,[esi+0x38]    ; eax = this-&gt;m_psb<BR>7151726a 6a01             push    0x1               ; TRUE<BR>7151726c 50               push    eax               ; "this" for callee<BR>7151726d 8b08             mov     ecx,[eax]         ; ecx = m_psb-&gt;lpVtbl<BR>7151726f ff5124           call    [ecx+0x24]        ; __stdcall EnableModelessSB<BR>        CancelPendingActions();<BR><BR></nobr></P>
<P>In order to call <b>CancelPendingActions</b>, you have to move from (ViewState*)this to (CUserView*)this. Note also that <b>CancelPendingActions</b> uses the __thiscall calling convention instead of __stdcall. According to __thiscall, the "this" pointer is passed in the ECX register instead of being passed on the stack.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>71517272 8d4eec           lea     ecx,[esi-0x14]    ; ecx = (CUserView*)this<BR>71517275 e832fbffff       call CUserView::CancelPendingActions (71516dac) ; __thiscall<BR>    ReleaseAndNull(&amp;_psf);<BR>7151727a 33ff             xor     edi,edi           ; edi = 0 (for later)<BR>No_Psv:<BR>7151727c 8d4678           lea     eax,[esi+0x78]    ; eax = &amp;_psf<BR>7151727f 50               push    eax               ; parameter<BR>71517280 ffd3             call    ebx               ; call ReleaseAndNull<BR>    if (fViewObjectChanged)<BR>71517282 397dfc           cmp     [ebp-0x4],edi     ; fViewObjectChanged == 0?<BR>71517285 740d             jz      NoNotifyViewClients (71517294) ; jump if zero<BR>       NotifyViewClients(DVASPECT_CONTENT, -1);<BR>71517287 8b46ec           mov     eax,[esi-0x14]    ; eax = ((CUserView*)this)-&gt;lpVtbl<BR>7151728a 8d4eec           lea     ecx,[esi-0x14]    ; ecx = (CUserView*)this<BR>7151728d 6aff             push    0xff              ; -1<BR>7151728f 6a01             push    0x1               ; DVASPECT_CONTENT = 1<BR>71517291 ff5024           call    [eax+0x24]        ; __thiscall NotifyViewClients<BR>NoNotifyViewClients:<BR>    if (m_pszTitle)<BR>71517294 8b8680000000     mov     eax,[esi+0x80]    ; eax = m_pszTitle<BR>7151729a 8d9e80000000     lea     ebx,[esi+0x80]    ; ebx = &amp;m_pszTitle (for later)<BR>715172a0 3bc7             cmp     eax,edi           ; eax == 0?<BR>715172a2 7409             jz      No_Title (715172ad) ; jump if zero<BR>        LocalFree(m_pszTitle);<BR>715172a4 50               push    eax               ; m_pszTitle<BR>715172a5 ff1538125071     call   [_imp__LocalFree]<BR>        m_pszTitle = NULL;<BR><BR></nobr></P>
<P>Remember that EDI is still zero and EBX is still &amp;m_pszTitle, because those registers are preserved by function calls.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>715172ab 893b             mov     [ebx],edi         ; m_pszTitle = 0<BR>No_Title:<BR>    SetRect(&amp;m_rcBounds, 0, 0, 0, 0);<BR>715172ad 57               push    edi               ; 0<BR>715172ae 57               push    edi               ; 0<BR>715172af 57               push    edi               ; 0<BR>715172b0 81c6fc000000     add     esi,0xfc          ; esi = &amp;this-&gt;m_rcBounds<BR>715172b6 57               push    edi               ; 0<BR>715172b7 56               push    esi               ; &amp;m_rcBounds<BR>715172b8 ff15e41a5071     call   [_imp__SetRect]<BR><BR></nobr></P>
<P>Notice that you do not need the value of "this" any more, so the compiler uses the <b>add</b> instruction to modify it in place instead of using up another register to hold the address. This is actually a performance win due to the Pentium u/v pipelining, because the v pipe can do arithmetic, but not address computations.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    return S_OK;<BR>715172be 33c0             xor     eax,eax           ; eax = S_OK<BR><BR></nobr></P>
<P>Finally, you restore the registers you are required to preserve, clean up the stack, and return to your caller, removing the incoming parameters.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>715172c0 5b               pop     ebx               ; restore<BR>ReturnNoEBX:<BR>715172c1 5f               pop     edi               ; restore<BR>715172c2 5e               pop     esi               ; restore<BR>715172c3 c9               leave                     ; restores EBP and ESP simultaneously<BR>715172c4 c20400           ret     0x4               ; return and clear parameters<BR><BR></nobr></P>
<P></P>
<P></P>
<DIV style="display:yes"></DIV>
<DIV CLASS="footer"><br><A href="dbglegal.htm">© 2009 Microsoft Corporation</A><br><A href="mailto:windbgfb@microsoft.com?subject=documentation feedback [Debugger]: Annotated x86 Disassembly RELEASE: (December 09, 2009)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AThe WDK team uses the feedback submitted to improve the WDK documentation. We do not use your e-mail address for any other purpose. We will remove your e-mail address from our system after the issue you are reporting has been resolved. While we are working to resolve this issue, we may send you an e-mail message to request more information about your feedback. After the issues have been addressed, we may send you an e-mail message to let you know that your feedback has been addressed.%0A%0AFor more information about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx.
              ">Send feedback on this topic</A><br>Debugging Tools for Windows<br>December 09, 2009<br></DIV>
</Body>
</HTML>
