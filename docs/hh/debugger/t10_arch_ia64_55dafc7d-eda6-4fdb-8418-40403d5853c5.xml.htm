<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/MSHelp">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>Annotated Itanium Disassembly</TITLE>
<META NAME="ms.locale" content="en-us">
<META NAME="DESCRIPTION" CONTENT="Debugger, Debugger, Design Guide, Annotated Itanium Disassembly"><xml><MSHelp:Keyword Index="A" Term="t10_arch_ia64_55dafc7d-eda6-4fdb-8418-40403d5853c5.xml"/>
<META NAME="MS-HKWD" CONTENT="Itanium processor, annotated disassembly">
<META NAME="MS-HKWD" CONTENT="Itanium processor, source code">
<META NAME="MS-HKWD" CONTENT="Itanium processor">
<META NAME="MS-HKWD" CONTENT="assembly code"></xml><LINK REL="stylesheet" type="text/css" href="backsdk4.css"><SCRIPT src="langref.js"></SCRIPT><style>dd {margin-bottom:0em; margin-left:1.9em; }</style>
<style>.divclass {behavior:url(#default#savehistory);}</style>
<META NAME="save" CONTENT="history">
</HEAD>
<Body topmargin="0">
<DIV STYLE="display:none;"></DIV>
<DIV STYLE="display:none;"></DIV>
<TABLE CLASS="buttonbarshade" CELLSPACING="0" border="0"><TR><TD NOWRAP="true"> </TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING="0">
<TR ID="hdr">
<TD NOWRAP="true" CLASS="runninghead">Debugging Tools for Windows</TD>
</TR>
</TABLE>
<H1><A NAME="t10_arch_ia64_55dafc7d-eda6-4fdb-8418-40403d5853c5.xml"></A>Annotated Itanium Disassembly</H1>
<P></P>
<P></P>
<P></P>
<H3><A NAME="d59df0c1-d8c8-468e-baba-51df1d4e2047"></A>Source Code</H3>
<P>The following is the code for the function that will be analyzed.</P>
<P></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>HRESULT CUserView::CloseView(void)<BR>{<BR>    if (m_fDestroyed) return S_OK;<BR><BR>    BOOL fViewObjectChanged = FALSE;<BR>    ReleaseAndNull(&amp;m_pdtgt);<BR><BR>    if (m_psv) {<BR>        m_psb-&gt;EnableModelessSB(FALSE);<BR>        if (m_pws) m_pws-&gt;ViewReleased();<BR><BR>        IShellView* psv;<BR><BR>        HWND hwndCapture = GetCapture();<BR>        if (hwndCapture &amp;&amp; hwndCapture == m_hwnd) {<BR>            SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);<BR>        }<BR><BR>        m_fHandsOff = TRUE;<BR>        m_fRecursing = TRUE;<BR>        NotifyClients(m_psv, NOTIFY_CLOSING);<BR>        m_fRecursing = FALSE;<BR><BR>        m_psv-&gt;UIActivate(SVUIA_DEACTIVATE);<BR><BR>        psv = m_psv;<BR>        m_psv = NULL;<BR><BR>        ReleaseAndNull(&amp;_pctView);<BR><BR>        if (m_pvo) {<BR>            IAdviseSink *pSink;<BR>            if (SUCCEEDED(m_pvo-&gt;GetAdvise(NULL, NULL, &amp;pSink)) &amp;&amp; pSink) {<BR>                if (pSink == (IAdviseSink *)this)<BR>                    m_pvo-&gt;SetAdvise(0, 0, NULL);<BR>                pSink-&gt;Release();<BR>            }<BR><BR>            fViewObjectChanged = TRUE;<BR>            ReleaseAndNull(&amp;m_pvo);<BR>        }<BR><BR>        if (psv) {<BR>            psv-&gt;SaveViewState();<BR>            psv-&gt;DestroyViewWindow();<BR>            psv-&gt;Release();<BR>        }<BR><BR>        m_hwndView = NULL;<BR>        m_fHandsOff = FALSE;<BR><BR>        if (m_pcache) {<BR>            GlobalFree(m_pcache);<BR>            m_pcache = NULL;<BR>        }<BR><BR>        m_psb-&gt;EnableModelessSB(TRUE);<BR><BR>        CancelPendingActions();<BR>    }<BR><BR>    ReleaseAndNull(&amp;_psf);<BR><BR>    if (fViewObjectChanged)<BR>        NotifyViewClients(DVASPECT_CONTENT, -1);<BR><BR>    if (m_pszTitle) {<BR>        LocalFree(m_pszTitle);<BR>        m_pszTitle = NULL;<BR>    }<BR><BR>    SetRect(&amp;m_rcBounds, 0, 0, 0, 0);<BR>    return S_OK;<BR>}<BR></nobr></P>
<H3><A NAME="816e75c4-f6fc-4a18-99ad-730844f0df68"></A>Assembly Code</H3>
<P>This section contains the annotated disassembly.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>HRESULT CUserView::CloseView(void)<BR><BR></nobr></P>
<P>On entry to a function, the parameters are passed in registers <b>r32</b> through <b>r39</b>. Remember that for C++ functions, the first parameter is the secret "this" pointer. Therefore, on entry to <b>CUserView::CloseView</b>, the registers are:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>r32 = this<BR>br = return address<BR><BR></nobr></P>
<P>Parameters are passed in <b>r32</b> through <b>r39</b>.</P>
<P>The <b>br</b> variable contains the function return address.</P>
<P>The Itanium separates its registers into several categories. The ones you will see most are <b>r</b> (regular integer registers), <b>b</b> (branch registers, used for branching), and <b>p</b> (predicate registers, which can hold the value TRUE or FALSE).</P>
<P>It so happens that <b>CloseView</b> is a method on <b>ViewState</b>, which is at offset 12 in the underlying object. This method will be referred to as "this," although when there is possible confusion with another base class, it will be more carefully specified as "(ViewState*)this".</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>sample!.CUserView__CloseView:<BR><BR></nobr></P>
<P>Notice that the symbol name is preceded by a dot. Recall that function pointers on the Itanium are not pointers to code. Instead, they point to a descriptor block (Intel calls it the PLABEL), which contains information about the function (including the address of its first instruction). <i>The symbol without a leading dot represents the function descriptor. The symbol with a leading dot is the first line of code.</i></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>{<BR>717796c0   {          alloc    r39 = ar.pfs, 0ah, 00h, 05h, 00h<BR>717796c4              mov      r40 = pr<BR><BR></nobr></P>
<P>The <b>alloc</b> instruction builds a stack frame. In this case, the stack frame has the local region with 10 (0ah) registers and it needs 5 output registers. Recall that in disassembly, the input registers and local registers are combined to form the local region. Because you know that you have only one parameter ("this"), there must be 9 local registers.</P>
<P><i>Every function begins with an alloc instruction.</i></P>
<P>Because you have a total of 10 registers in your local region, and the local region begins with register <b>r32</b>, the local region registers must be <b>r32</b> through <b>r41</b>, leaving <b>r42</b> through <b>r46</b> as the 5 output registers.</P>
<P>The second instruction saves the predicate registers (<b>pr</b>) into register <b>r40</b>. This allows the predicate registers to be restored before the function returns.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    if (m_fDestroyed) return S_OK;<BR>717796c8              adds     r31 = 0180h, r32          }// r31 = &amp;this-&gt;m_fDestroyed<BR><BR></nobr></P>
<P>This is equivalent to "<b>r31</b> = 0180h + <b>r32</b>". The <b>adds</b> instruction adds a small integer to a register. There is a corresponding <b>addl</b> instruction that adds a large integer, but it can only add to registers <b>r0</b>, <b>gp</b>, <b>r2</b>, and <b>r3</b>.</P>
<P><i>Arithmetic operations are of the form "op dst = src, src, src".</i></P>
<P>Before proceeding with the computations, you need to finish the function prologue.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>717796d0   {          adds     sp = -32, sp ;;    // local stack space<BR>717796d4              ld8.nta  r3 = [sp]          // stack probe<BR>717796d8              mov      r38 = rp       } // save return address<BR>717796e0   {          or       r41 = gp, r0 ;;    // save gp<BR><BR></nobr></P>
<P>Notice that the integer argument to the <b>adds sp</b> instruction is disassembled in decimal rather than hexadecimal. However, the debugger default is to assume hexadecimal for all inputs, so the command <a href="r15_cmds_a_c6ea44eb-73b8-451d-8054-ded9b17ac2bd.xml.htm"><b>?sp-32</b></a> will typically display as "sp-0x32". You can use the <a href="r17_cmds_i_d2b1e43f-2f4b-4746-b038-0b360a63e458.xml.htm"><b>n (Set Number Base)</b></a> command to change the default radix to 10. (The default radix can be overridden with the 0x hexadecimal prefix or the 0n decimal prefix.)</P>
<P></P>
<P>The next <b>adds</b> instruction allocates some space on the stack. It is followed by a <b>load</b> instruction that appears unusual.</P>
<P><i>The ld instruction loads a register from memory.</i></P>
<P>The "nta" suffix means "this memory location will not be accessed for a long time" and is an indication to the processor to allow it to better optimize its L2 cache. The only place you will see it in regular code is at the top of a function to perform a stack probe.</P>
<P>The third instruction saves the return address into register <b>r38</b> so you know where to go when this function is finished.</P>
<P>The fourth instruction says, "r41 = gp | r0".</P>
<P><i>The r0 register is hard-wired to the value zero.</i></P>
<P>Therefore, ORing something with zero and storing the result is the same as copying the value.</P>
<P><i>"or dest = src, r0" copies a register.</i></P>
<P><i>The gp register, by convention, always points to the current module's global variables.</i></P>
<P></P>
<P>Because you are calling functions that might belong to other DLLs, you need to save the <b>gp</b> register so you can access your global variables after calling those functions. This will require the <b>gp</b> register to point to <i>their</i> global variables.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>717796e4              ld4      r31 = [r31]       // r31 = m_fDestroyed<BR>717796e8              nop.i    00h ;;            }<BR><BR></nobr></P>
<P>The <b>ld4</b> instruction is another memory fetch, but this time you load only 32 bits (4 bytes) from memory instead of a full 64 bits.</P>
<P><i>The ld4 instruction zero-extends the loaded value to 64 bits.</i></P>
<P>The next instruction is a NOP. The suffix indicates that this is actually an integer NOP However, this is not important, because the instruction does nothing.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>717796f0   {          cmp4.eq  p14, p15 = r0, r31         // if m_fDestroyed<BR>717796f4              nop.f    00h<BR>717796f8     (p15)    br.cond.dpnt.few  $+07c0h ;;       }// jump if not to ReturnSOK<BR><BR></nobr></P>
<P>The <b>cmp4.eq</b> instruction compares the bottom 32 bits of the two registers <b>r0</b> and <b>r31</b>. The result of the comparison is saved into the <b>p14</b> register, and the opposite result is saved to <b>p15</b>.</P>
<P><i>The cmp instruction compares two registers. The result of the comparison is saved in the first destination register; the opposite is saved in the second destination register.</i></P>
<P>The <b>cmp4.eq</b> instruction compares the <b>r31</b> register (which you just loaded) with <b>r0</b> (which is zero). If the registers are equal, then <b>p14</b> is set to TRUE; otherwise, <b>p14</b> is set to FALSE. The <b>p15</b> register is set to the opposite of <b>p14</b> (that is, FALSE or TRUE, respectively).</P>
<P>After another NOP, check the result of the comparison.</P>
<P><i>A parenthesized register in the left margin indicates that the instruction is executed only if that register is TRUE.</i></P>
<P>In this case, you execute the branch instruction only if the <b>p15</b> register is TRUE, which happens when the previous comparison is FALSE, because <b>p15</b> was the second destination of the comparison. <b> </b></P>
<P>The suffixes on the <b>br.cond</b> instruction are hints to the processor for optimization and do not affect the execution semantics.</P>
<P>The target of the branch instruction is not quite right. The target is disassembled as $+07c0h, but the actual target address is 07b8h bytes away. That is because the branch target is computed relative to the beginning of the instruction bundle (in other words, relative to the preceding open brace). Thus, when you are disassembling through code and trying to follow the flow of the code, be careful how you compute your jump targets.</P>
<P><i>Jump instructions are relative to the start of the bundle, not to the start of the instruction.</i></P>
<P>Now you can see how that <b>gp</b> register gets used. The compiler has interleaved some instructions for performance, so the next step it does is actually the initial step for calling an imported function.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    ReleaseAndNull(&amp;m_pdtgt);<BR>71779700   {          addl     r31 = -2025856, gp         // r31 = &amp;__imp__ReleaseAndNull<BR>71779704              adds     r42 = 0198h, r32           // r42 = &amp;this-&gt;m_pdtgt<BR><BR></nobr></P>
<P>Because the <b>gp</b> register points to your global variables, the <b>addl</b> instruction against the <b>gp</b> register is computing the address of a global variable. In this case, it is the import table entry for the <b>ReleaseAndNull</b> function.</P>
<P>As you computed at the beginning of the function, the output registers start at <b>r42</b>, and here you see the first output register being loaded with the address of the <i>m_pdtgt</i> member. This is the first, and in this case, the only parameter of <b>ReleaseAndNull</b>.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    if (m_psv)<BR>71779708              adds     r33 = 0110h, r32          }// r33 = &amp;this-&gt;m_psv<BR><BR></nobr></P>
<P>The compiler has aggressively started emitting instructions for the line two ahead of where you are.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    BOOL fViewObjectChanged = FALSE;<BR>71779710   {          or       r37 = r0, r0 ;;             ; r37 = 0<BR><BR></nobr></P>
<P>The compiler used the <b>r37</b> register to represent the local variable fViewObjectChanged. Because the <b>r0</b> register is hard-wired to zero, the OR instruction zeroes out the <b>r37</b> register.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    ReleaseAndNull(&amp;m_pdtgt);<BR>71779714              ld8      r31 = [r31]                // r31 = &amp;ReleaseAndNull<BR>71779718              nop.i    00h ;;                    }<BR>71779720   {          ld8      r30 = [r31], 08h ;;        // r30 = .ReleaseAndNull<BR>71779724              ld8      gp = [r31]                 // gp  = gp.ReleaseAndNull<BR>71779728              mov      b6 = r30, $+0x0           }// b6  = .ReleaseAndNull<BR>71779730   {          nop.m    00h<BR>71779734              nop.f    00h<BR>71779738              br.call.dptk.many  rp = b6 ;;      }// call .ReleaseAndNull<BR><BR></nobr></P>
<P>Here is the remainder of the function call. Recall that a function pointer is really a pointer to a descriptor. Thus, after getting the address of the descriptor, you read the actual code address and the <b>gp</b> of the target function.</P>
<P>The following diagram outlines this concept.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>__imp__Function    Function            .Function<BR>+--------------+   +---------------+   +-----------------------+<BR>| Function    ---&gt; | code pointer ---&gt; | code...               |<BR>+--------------+   +---------------+   |                       |<BR>                   | gp            |   |                       |<BR>                   +---------------+   |                       |<BR></nobr></P>
<P>Remember, a function name without a period in front of it refers to the function descriptor. The function with a period represents the first line of code.</P>
<P><i>"ld dest = [src], n" is a post-incremented load.</i></P>
<P>In this case, "ld8 r30 = [r31], 08h" means "load the <b>r30</b> register from the 8 bytes pointed to by <b>r31</b>, and then increment <b>r31</b> by 8."</P>
<P>After you load the code address into <b>r30</b>, you move it into the <b>b6</b> register so you can branch to it. You cannot move from memory directly into a branch register; you have to go through a regular integer register.</P>
<P>Finally, execute a <b>br.call</b> instruction to call the target function. (Again, the other suffixes are optimization indications.)</P>
<P>You will see this pattern repeatedly; it is the template for calling an imported function. </P><B>To call an imported function</B><OL type="1">
<LI>Load the address of the import table </LI>
<LI>Load  from the import table to get the descriptor </LI>
<LI>Load the code address from the descriptor, with postincrement +8 </LI>
<LI>Load the <b>gp</b> register from the descriptor</LI>
<LI>Move the code address into a branch register</LI>
<LI>Call through the branch register</LI>
</OL>
<P></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    if (m_psv)<BR>71779740   {          ld8      r29 = [r33]                // r29 = m_psv<BR>71779744              or       gp = r41, r0 ;;            // restore gp<BR>71779748              cmp.eq   p14, p15 = r0, r29        }// m_psv == 0?<BR>71779750   {          nop.m    00h<BR>71779754              nop.f    00h<BR>71779758     (p14)    br.cond.dpnt.few  $+0620h ;;       }// Y: jump to NoPSV<BR><BR></nobr></P>
<P>After control returns, dereference the <b>r33</b> register, which you set up before calling <b>ReleaseAndNull</b>. The processor automatically preserves the local region across calls, so the <b>r33</b> register still contains the value you set up earlier.</P>
<P>After returning from the imported function call, restore the gp register to point to your own global registers so you can access them once again. (Though theoretically this often is not necessary because you do not access any global variables before the next call that discards it anyway.)</P>
<P>The following is again a comparison followed by a predicated branch instruction. Check if the value you loaded is zero and branch it if it is.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_psb-&gt;EnableModelessSB(FALSE);<BR>71779760   {          adds     r36 = 0a0h, r32            // r36 = &amp;this-&gt;m_psb<BR>71779764              addl     r43 = 00h, r0              // r43 = 0<BR>71779768              nop.b    00h ;;                    }<BR>71779770   {          ld8      r42 = [r36] ;;             // r42 = this-&gt;m_psb<BR>71779774              ld8      r31 = [r42]                // r31 = this-&gt;m_psb.vtbl<BR>71779778              nop.i    00h ;;                    }<BR>71779780   {          adds     r31 = 048h, r31 ;;         // r31 = &amp;vtbl.EnableModelessSB<BR>71779784              ld8      r30 = [r31]                // r30 = &amp;EnableModelessSB<BR>71779788              nop.i    00h ;;                    }<BR>71779790   {          ld8      r29 = [r30], 08h ;;        // r29 = .EnableModelessSB<BR>71779794              ld8      gp = [r30]                 // gp  = gp.EnableModelessSB<BR>71779798              mov      b6 = r29, $+0x0           }// b6  = .EnableModelessSB<BR>717797a0   {          nop.m    00h<BR>717797a4              nop.f    00h<BR>717797a8              br.call.dptk.many  rp = b6 ;;      }// call .EnableModelessSB<BR><BR></nobr></P>
<P>Now you get to see how a virtual C++ method call gets compiled. As before, registers <b>r42</b> and <b>r43</b> receive the parameters to the function.</P>
<P>This time, instead of getting the function pointer from your <b>gp</b>, you load the <b>vtbl</b> out of m_psb, step forward to the method you want to call, then set up for another function call.</P>
<P>The following diagram outlines this process.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>object      object vtbl<BR>+-------+   +-----------------+<BR>| vtbl ---&gt; | QueryInterface  |<BR>+-------+   +-----------------+<BR>| ...   |   | AddRef          |<BR>            +-----------------+<BR>            | Release         |<BR>            +-----------------+<BR>            | ...             |   EnableModeless      .EnableModeless<BR>            +-----------------+   +---------------+   +-----------------------+<BR>            | EnableModeless ---&gt; | code pointer ---&gt; | code...               |<BR>            +-----------------+   +---------------+   |                       |<BR>            | ...             |   | gp            |   |                       |<BR>                                  +---------------+   |                       |<BR><BR></nobr></P>
<P>The following is a pattern you should recognize.</P><B>How to compile a virtual C++ method</B><OL type="1">
<LI>Load the object into an output register.</LI>
<LI>Load the <b>vtbl</b> from the object. </LI>
<LI>Add to the <b>vtbl</b> to get to the function you want to call. </LI>
<LI>Load from the <b>vtbl</b> to get the descriptor. </LI>
<LI>Load the code address from the descriptor, with postincrement +8. </LI>
<LI>Load the <b>gp</b> register from the descriptor. </LI>
<LI>Move the code address into a branch register.</LI>
<LI>Call through the branch register.</LI>
</OL>
<P></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if (m_pws) m_pws-&gt;ViewReleased();<BR>717797b0   {          adds     r28 = 0228h, r32           // r28 = &amp;this-&gt;m_pws<BR>717797b4              or       gp = r41, r0               // restore gp after call<BR>717797b8              nop.b    00h ;;                    }<BR>717797c0   {          ld8      r42 = [r28] ;;             // r42 = this-&gt;m_pws<BR>717797c4              cmp.eq   p14, p15 = r0, r42         // equal to zero?<BR>717797c8              nop.i    00h                       }<BR>717797d0   {          nop.m    00h<BR>717797d4              nop.f    00h<BR>717797d8     (p14)    br.cond.dpnt.few  $+050h ;;        }// Y: Jump to NoWS<BR>717797e0   {          ld8      r31 = [r42] ;;             // r31 = this-&gt;m_pws.vtbl<BR>717797e4              adds     r31 = 018h, r31            // r31 = &amp;vtbl.ViewReleased<BR>717797e8              nop.i    00h ;;                    }<BR>717797f0   {          ld8      r30 = [r31] ;;             // r30 = &amp;ViewReleased<BR>717797f4              ld8      r29 = [r30], 08h           // r29 = .ViewReleased<BR>717797f8              nop.i    00h ;;                    }<BR>71779800   {          ld8      gp = [r30]                 // gp  = gp.ViewReleased<BR>71779804              mov      b6 = r29, $+0x0            // b6  = ViewReleased<BR>71779808              br.call.dptk.many  rp = b6 ;;      }// call  .ViewReleased<BR>71779810   {          or       gp = r41, r0               // restore gp after call<BR>71779814              nop.f    00h<BR>71779818              nop.b    00h ;;                    }<BR>NoWS:<BR><BR></nobr></P>
<P>You are now familiar enough to read the following entire code sequence, which consists of another variable test, conditional jump, and method call:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        HWND hwndCapture = GetCapture();<BR>71779820   {          addl     r31 = -2024992, gp ;;      // r31 = &amp;__imp__GetCapture<BR>71779824              ld8      r30 = [r31]                // r30 = &amp;GetCapture<BR>71779828              nop.i    00h ;;                    }<BR>71779830   {          ld8      r29 = [r30], 08h ;;        // r29 = .GetCapture<BR>71779834              ld8      gp = [r30]                 // gp  = gp.GetCapture<BR>71779838              mov      b6 = r29, $+0x0           }// b6  = .GetCapture<BR>71779840   {          nop.m    00h<BR>71779844              nop.f    00h<BR>71779848              br.call.dptk.many  rp = b6 ;;      }// call .GetCapture<BR>71779850   {          or       gp = r41, r0               // restore gp after call<BR><BR></nobr></P>
<P>Again, a pattern you already recognize, but this time it is a call to an imported function:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if (hwndCapture &amp;&amp; hwndCapture == m_hwnd) {<BR>71779854              cmp.eq   p14, p15 = r0, ret0        // hwndCapture == NULL?<BR>71779858     (p14)    br.cond.dpnt.few  $+080h ;;        }// Y: Jump to NoCapture<BR>71779860   {          adds     r31 = 0b8h, r32 ;;         // r31 = &amp;this-&gt;m_hwnd<BR>71779864              ld8      r42 = [r31]                // r42 = this-&gt;m_hwnd<BR>71779868              nop.i    00h ;;                    }<BR>71779870   {          cmp.eq   p15, p14 = ret0, r42       // hwndCapture == this-&gt;m_hwnd?<BR>71779874              nop.f    00h<BR>71779878     (p14)    br.cond.dptk.few  $+060h ;;        }// Y: Jump to NoCapture<BR><BR></nobr></P>
<P><i>Functions return their value in the ret0 register.</i></P>
<P>Check if hwndCapture is NULL or equal to m_hwnd, and jump if either condition is met.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            SendMessage(m_hwnd, WM_CANCELMODE, 0, 0);<BR>        }<BR>71779880   {          addl     r31 = -2025920, gp         // r31 = &amp;__imp__SendMessage<BR>71779884              addl     r45 = 00h, r0              // r45 = 0 (lParam)<BR>71779888              addl     r44 = 00h, r0             }// r44 = 0 (wParam)<BR>71779890   {          addl     r43 = 01fh, r0 ;;          // r43 = WM_CANCELMODE (uMsg)<BR>71779894              ld8      r30 = [r31]                // r30 = &amp;SendMessage<BR>71779898              nop.i    00h ;;                    }<BR>717798a0   {          ld8      r29 = [r30], 08h ;;        // r29 = .SendMessage<BR>717798a4              ld8      gp = [r30]                 // gp  = gp.SendMessage<BR>717798a8              mov      b6 = r29, $+0x0           }// b6  = .SendMessage<BR>717798b0   {          nop.m    00h<BR>717798b4              nop.f    00h<BR>717798b8              br.call.dptk.many  rp = b6 ;;      }// call .SendMessage<BR>717798c0   {          or       gp = r41, r0               // restore gp after call<BR>717798c4              nop.f    00h<BR>717798c8              nop.b    00h                       }<BR>NoCapture:<BR><BR></nobr></P>
<P>This time, you have to call a function that takes four parameters, so you fill the output registers <b>r42</b> through <b>r45</b> with the parameters. Note that you set up <b>r42</b> ahead of time while you were still deciding whether to call <b>SendMessage</b>.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_fHandsOff = TRUE;<BR>        m_fRecursing = TRUE;<BR>        NotifyClients(m_psv, NOTIFY_CLOSING);<BR>717798d0   {          ld8      r43 = [r33]                // r43 = m_psv<BR>717798d4              adds     r42 = 040h, r32            // r42 = (CNotifySource*)this<BR>717798d8              adds     r35 = 0218h, r32          }// r35 = &amp;this-&gt;bitfield<BR>717798e0   {          addl     r31 = 08001h, r0 ;;        // r31 = 0x8001<BR>717798e4              addl     r44 = 04h, r0              // r44 = 4<BR>717798e8              nop.i    00h ;;                    }<BR>717798f0   {          ld8      r29 = [r42]                // r29 = (CNotifySource*)this-&gt;vtbl<BR>717798f4              ld4      r30 = [r35]                // r30 = bitfield<BR>717798f8              nop.b    00h ;;                    }<BR>71779900   {          or       r31 = r31, r30 ;;          // set the two bits in r30<BR>71779904              st4      [r35] = r31                // store the result<BR><BR></nobr></P>
<P>Now you get to see how bitfields get compiled, with some instructions from the upcoming method call interleaved. Recall that you set up the <b>r33</b> register to point to the m_psv member, so all you have to do is dereference it to fetch the value.</P>
<P>The other instructions prepare for the method call by setting up the output registers (<b>r42</b> through<b> r44</b>) and loading the <b>vtbl</b> of m_psv.</P>
<P>Meanwhile, the two bits in the bitfield are set by loading the full bitfield, ORing the values, then storing the result.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        NotifyClients(m_psv, NOTIFY_CLOSING);<BR>71779908              adds     r29 = 018h, r29 ;;        }// r29 = &amp;vtbl.NotifyClients<BR>71779910   {          ld8      r30 = [r29] ;;             // r30 = NotifyClients<BR>71779914              ld8      r31 = [r30], 08h           // r31 = .NotifyClients<BR>71779918              nop.i    00h ;;                    }<BR>71779920   {          ld8      gp = [r30]                 // gp  = gp.NotifyClients<BR>71779924              mov      b6 = r31, $+0x0            // b6  = .NotifyClients<BR>71779928              br.call.dptk.many  rp = b6 ;;      }// call .NotifyClients<BR><BR></nobr></P>
<P>Here is the rest of the method call:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_fRecursing = FALSE;<BR>71779930   {          ld4      r28 = [r35]                // r28 = bitfield<BR>71779934              ld8      r42 = [r33]                // r42 = m_psv<BR>71779938              addl     r29 = -32769, r0 ;;       }// r29 = ~0x8000<BR>71779940   {          and      r29 = r29, r28             // r29 = bitfield &amp; ~0x8000<BR>71779944              or       gp = r41, r0               // restore gp after call<BR>71779948              addl     r43 = 00h, r0 ;;          }// r43 = 0 (SVUIA_DEACTIVATE)<BR>71779950   {          st4      [r35] = r29                // store updated bitfield<BR><BR></nobr></P>
<P>Here is how to clear a bit in a bitfield:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_psv-&gt;UIActivate(SVUIA_DEACTIVATE);<BR>71779954              ld8      r31 = [r42]                // r31 = m_psv.vtbl<BR>71779958              nop.b    00h ;;                    }<BR>71779960   {          adds     r31 = 038h, r31 ;;         // r31 = &amp;vtbl.UIActivate<BR>71779964              ld8      r30 = [r31]                // r30 = &amp;UIActivate<BR>71779968              nop.i    00h ;;                    }<BR>71779970   {          ld8      r29 = [r30], 08h ;;        // r29 = .UIActivate<BR>71779974              ld8      gp = [r30]                 // gp  = gp.UIActivate<BR>71779978              mov      b6 = r29, $+0x0           }// b6  = .UIActivate<BR>71779980   {          nop.m    00h<BR>71779984              nop.f    00h<BR>71779988              br.call.dptk.many  rp = b6 ;;      }// call .UIActivate<BR><BR></nobr></P>
<P>These method calls are becoming routine.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        psv = m_psv;<BR>        m_psv = NULL;<BR>        ReleaseAndNull(&amp;_pctView);<BR>71779990   {          ld8      r34 = [r33]                // r34 (psv) = m_psv<BR>71779994              or       gp = r41, r0               // restore gp after call<BR>71779998              adds     r42 = 0100h, r32          }// r42 = &amp;this-&gt;_bbt._pctView<BR>717799a0   {          st8      [r33] = r0 ;;              // m_psv = 0<BR>717799a4              addl     r31 = -2025856, gp         // r31 = &amp;__imp__ReleaseAndNull<BR>717799a8              nop.i    00h ;;                    }<BR>717799b0   {          ld8      r30 = [r31] ;;             // r30 = &amp;ReleaseAndNull<BR>717799b4              ld8      r29 = [r30], 08h           // r29 = .ReleaseAndNull<BR>717799b8              nop.i    00h ;;                    }<BR>717799c0   {          ld8      gp = [r30]                 // gp  = gp.ReleaseAndNull<BR>717799c4              mov      b6 = r29, $+0x0            // b6  = .ReleaseAndNull<BR>717799c8              br.call.dptk.many  rp = b6 ;;      }// call .ReleaseAndNull<BR><BR></nobr></P>
<P>Another method call, with some variable rearranging in it:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if (m_pvo) {<BR>717799d0   {          adds     r33 = 0178h, r32           // r33 = &amp;this-&gt;m_pvo<BR>717799d4              or       gp = r41, r0               // restore gp after call<BR>717799d8              nop.b    00h ;;                    }<BR>717799e0   {          ld8      r42 = [r33] ;;             // r42 = this-&gt;m_pvo<BR>717799e4              cmp.eq   p14, p15 = r0, r42         // m_pvo == NULL?<BR>717799e8              nop.i    00h                       }<BR>717799f0   {          nop.m    00h<BR>717799f4              nop.f    00h<BR>717799f8     (p14)    br.cond.dpnt.few  $+01a0h ;;       }// Y: Jump to NoPVO<BR><BR></nobr></P>
<P>Simply checking a variable:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            IAdviseSink *pSink;<BR>            if (SUCCEEDED(m_pvo-&gt;GetAdvise(NULL, NULL, &amp;pSink)) ...<BR>71779a00   {          ld8      r31 = [r42]                // r31 = this-&gt;m_pvo-&gt;vtbl<BR>71779a04              adds     r45 = 010h, sp             // r45 = &amp;pSink<BR>71779a08              addl     r44 = 00h, r0             }// r44 = NULL<BR>71779a10   {          addl     r43 = 00h, r0 ;;           // r43 = NULL<BR>71779a14              adds     r37 = 010h, sp             // r37 = &amp;pSink<BR>71779a18              nop.i    00h ;;                    }<BR>71779a20   {          adds     r31 = 040h, r31 ;;         // r31 = &amp;vtbl.GetAdvise<BR>71779a24              ld8      r30 = [r31]                // r30 = &amp;GetAdvise<BR>71779a28              nop.i    00h ;;                    }<BR>71779a30   {          ld8      r29 = [r30], 08h ;;        // r29 = .GetAdvise<BR>71779a34              ld8      gp = [r30]                 // gp  = gp.GetAdvise<BR>71779a38              mov      b6 = r29, $+0x0           }// b6  = .GetAdvise<BR>71779a40   {          nop.m    00h<BR>71779a44              nop.f    00h<BR>71779a48              br.call.dptk.many  rp = b6 ;;      }// call .GetAdvise<BR><BR></nobr></P>
<P>Now call the <b>GetAdvise</b> method, and check the return value.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            if (SUCCEEDED(...) &amp;&amp; pSink) {<BR>71779a50   {          ld8      r42 = [r37]                // r42 = pSink<BR>71779a54              cmp4.eq  p14, p15 = 01h, r0         // p14 = FALSE, p15 = TRUE<BR>71779a58              or       gp = r41, r0 ;;           }// restore gp after call<BR>71779a60   {          cmp4.gt.or.andcm  p14, p15 = r0, ret0 // if (0 &gt; ret0) { p14 = TRUE; p15 = FALSE }<BR>71779a64              cmp.eq.or.andcm  p14, p15 = r0, r42 // if (0 == pSink) { p14 = TRUE; p15 = FALSE }<BR>71779a68     (p14)    br.cond.dpnt.few  $+0f0h ;;        }// if FAILED or NULL, jump to NoSink<BR><BR></nobr></P>
<P>Now you see the unusual conditional instructions in action.</P>
<P>The first comparison instruction seems pointless in that it compares one against zero. It does this to initialize the predicate registers <b>p14</b> to FALSE and <b>p15</b> to TRUE.</P>
<P>The next two comparison instructions execute in parallel. The first one checks if 0 &gt; ret0; that is, if the return value is negative. The next two suffixes indicate that the result is ORed into the first destination and complemented and ANDed (<b>andcm</b>) with the second destination.</P>
<P>After doing the combination testing, you jump if <b>p14</b> is TRUE, which happens if one of the combination tests was true.</P>
<P>There are two interesting points to note about this sequence. First, the two combination comparisons were executed in parallel. (Notice that they execute as part of the same instruction group.) Second, you only executed a single conditional jump. Furthermore, that conditional jump was part of the same instruction group, so it all executes in a single cycle.</P>
<P>A traditional CPU would have had to test the return value, jump conditionally, then test pSink, and jump conditionally again.Those four operations are dependent on each other, so it would take four cycles to perform the combination test instead of the one cycle that the Itanium required.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                if (pSink == (IAdviseSink *)this)<BR>71779a70   {          adds     r31 = -40, r32 ;;          // r31 = (CUserView*)this<BR>71779a74              cmp.eq   p14, p15 = r0, r31         // r31 == NULL?<BR>71779a78              adds     r31 = 028h, r32           }// r31 = (IAdviseSink*)this<BR>71779a80   {          nop.m    00h<BR>71779a84              nop.f    00h<BR>71779a88     (p15)    br.cond.dpnt.few  $+020h ;;        }// N: Jump to NotNULL<BR>71779a90   {          or       r31 = r0, r0               // r31 = NULL<BR>71779a94              nop.f    00h<BR>71779a98              nop.b    00h ;;                    }<BR>NotNULL:<BR><BR></nobr></P>
<P>This is a quirk of the C++ specification, namely that if p is a NULL pointer, then (T*)p must be equal to NULL for all types T. This means that changing from one base class to another requires the compiler to stick in special checks for NULL.</P>
<P>At the end of the following sequence, the <b>r31</b> register contains the result of the cast (IAdviseSink*).</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                if (pSink == (IAdviseSink *)this)<BR>                    m_pvo-&gt;SetAdvise(0, 0, NULL);<BR>71779aa0   {          cmp.eq   p15, p14 = r42, r31        // r31 == pSink?<BR>71779aa4              nop.f    00h<BR>71779aa8     (p14)    br.cond.dptk.few  $+070h ;;        }// N: Jump to NotSameSink<BR>71779ab0   {          ld8      r42 = [r33]                // r42 = this-&gt;m_pvo<BR>71779ab4              addl     r45 = 00h, r0              // r45 = 0<BR>71779ab8              addl     r44 = 00h, r0             }// r44 = 0<BR>71779ac0   {          addl     r43 = 00h, r0 ;;           // r43 = NULL<BR>71779ac4              ld8      r31 = [r42]                // r31 = this-&gt;m_pvo-&gt;vtbl<BR>71779ac8              nop.i    00h ;;                    }<BR>71779ad0   {          adds     r31 = 038h, r31 ;;         // r31 = &amp;vtbl.SetAdvise<BR>71779ad4              ld8      r30 = [r31]                // r30 = SetAdvise<BR>71779ad8              nop.i    00h ;;                    }<BR>71779ae0   {          ld8      r29 = [r30], 08h ;;        // r29 = .SetAdvise<BR>71779ae4              ld8      gp = [r30]                 // gp  = gp.SetAdvise<BR>71779ae8              mov      b6 = r29, $+0x0           }// b6  = .SetAdvise<BR>71779af0   {          nop.m    00h<BR>71779af4              nop.f    00h<BR>71779af8              br.call.dptk.many  rp = b6 ;;      }// call .SetAdvise<BR>71779b00   {          ld8      r42 = [r37]                //r42 = pSink (restore register variable)<BR>71779b04              or       gp = r41, r0               // restore gp after call<BR>71779b08              nop.b    00h ;;                    }<BR>NotSameSink:<BR><BR></nobr></P>
<P>Notice that the compiler had to reload the <b>r42</b> register after the call, because <b>r42</b> is an output register, and output registers can be modified across a call. (That is not important in this case, because you also explicitly destroyed the<b> r42</b> register.)</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>                pSink-&gt;Release();<BR>            }<BR>71779b10   {          ld8      r31 = [r42] ;;             // r31 = pSink-&gt;vtbl<BR>71779b14              adds     r31 = 010h, r31            // r31 = &amp;vtbl.Release<BR>71779b18              nop.i    00h ;;                    }<BR>71779b20   {          ld8      r30 = [r31] ;;             // r30 = &amp;Release<BR>71779b24              ld8      r29 = [r30], 08h           // r29 = .Release<BR>71779b28              nop.i    00h ;;                    }<BR>71779b30   {          ld8      gp = [r30]                 // gp  = gp.Release<BR>71779b34              mov      b6 = r29, $+0x0            // b6  = .Release<BR>71779b38              br.call.dptk.many  rp = b6 ;;      }// call .Release<BR>71779b40   {          or       gp = r41, r0               // restore gp after call<BR>71779b44              nop.f    00h<BR>71779b48              nop.b    00h ;;                    }<BR>NoSink:<BR><BR></nobr></P>
<P>Another method call:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            fViewObjectChanged = TRUE;<BR>            ReleaseAndNull(&amp;m_pvo);<BR>        }<BR>71779b50   {          addl     r31 = -2025856, gp         // r31 = &amp;__imp__ReleaseAndNull<BR>71779b54              or       r42 = r33, r0              // r42 = r33 = &amp;this-&gt;m_pvo<BR>71779b58              addl     r37 = 01h, r0 ;;          }// r37 (fViewObjectChanged) = 1 = TRUE<BR>71779b60   {          ld8      r30 = [r31] ;;             // r30 = &amp;ReleaseAndNull<BR>71779b64              ld8      r29 = [r30], 08h           // r29 = .ReleaseAndNull<BR>71779b68              nop.i    00h ;;                    }<BR>71779b70   {          ld8      gp = [r30]                 // gp  = gp.ReleaseAndNull<BR>71779b74              mov      b6 = r29, $+0x0            // b6  = .ReleaseAndNull<BR>71779b78              br.call.dptk.many  rp = b6 ;;      }// call .ReleaseAndNull<BR>71779b80   {          or       gp = r41, r0               // restore gp after call<BR>71779b84              nop.f    00h<BR>71779b88              nop.b    00h                       }<BR><BR></nobr></P>
<P>Recall that the fViewObjectChanged local variable is being kept in the <b>r37</b> register.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if (psv) {<BR>            psv-&gt;SaveViewState();<BR>            psv-&gt;DestroyViewWindow();<BR>            psv-&gt;Release();<BR>        }<BR>71779b90   {          cmp.eq   p14, p15 = r0, r34         // r34 (psv) == NULL?<BR>71779b94              nop.f    00h<BR>71779b98     (p14)    br.cond.dptk.few  $+0d0h ;;        }// Y: Jump to NoPSV2<BR>71779ba0   {          ld8      r31 = [r34]                // r31 = psv-&gt;vtbl<BR>71779ba4              or       r42 = r34, r0 ;;           // r42 = psv<BR>71779ba8              adds     r31 = 068h, r31 ;;        }// r31 = &amp;vtbl.SaveViewState<BR>71779bb0   {          ld8      r30 = [r31] ;;             // r30 = &amp;SaveViewState<BR>71779bb4              ld8      r29 = [r30], 08h           // r29 = .SaveViewState<BR>71779bb8              nop.i    00h ;;                    }<BR>71779bc0   {          ld8      gp = [r30]                 // gp  = gp.SaveViewState<BR>71779bc4              mov      b6 = r29, $+0x0            // b6  = .SaveViewState<BR>71779bc8              br.call.dptk.many  rp = b6 ;;      }// call .SaveViewState<BR><BR>71779bd0   {          ld8      r28 = [r34]                // r28 = psv-&gt;vtbl<BR>71779bd4              or       gp = r41, r0               // restore gp after call (pointless)<BR>71779bd8              or       r42 = r34, r0 ;;          }// r42 = psv<BR>71779be0   {          adds     r31 = 050h, r28 ;;         // r31 = &amp;vtbl.DestroyViewWindow<BR>71779be4              ld8      r29 = [r31]                // r29 = &amp;DestroyViewWindow<BR>71779be8              nop.i    00h ;;                    }<BR>71779bf0   {          ld8      r27 = [r29], 08h ;;        // r27 = .DestroyViewWindow<BR>71779bf4              ld8      gp = [r29]                 // gp  = gp.DestroyViewWindow<BR>71779bf8              mov      b6 = r27, $+0x0           }// b6  = .DestroyViewWindow<BR>71779c00   {          nop.m    00h<BR>71779c04              nop.f    00h<BR>71779c08              br.call.dptk.many  rp = b6 ;;      }// call .DestroyViewWindow<BR><BR>71779c10   {          ld8      r30 = [r34]                // r30 = psv-&gt;vtbl<BR>71779c14              or       gp = r41, r0               // restore gp after call (pointless)<BR>71779c18              or       r42 = r34, r0 ;;          }// r42 = psv<BR>71779c20   {          adds     r31 = 010h, r30 ;;         // r31 = &amp;vtbl.Release<BR>71779c24              ld8      r28 = [r31]                // r28 = &amp;Release<BR>71779c28              nop.i    00h ;;                    }<BR>71779c30   {          ld8      r29 = [r28], 08h ;;        // r29 = .Release<BR>71779c34              ld8      gp = [r28]                 // gp  = gp.Release<BR>71779c38              mov      b6 = r29, $+0x0           }// b6  = .Release<BR>71779c40   {          nop.m    00h<BR>71779c44              nop.f    00h<BR>71779c48              br.call.dptk.many  rp = b6 ;;      }// call .Release<BR>71779c50   {          or       gp = r41, r0               // restore gp after call<BR>71779c54              nop.f    00h<BR>71779c58              nop.b    00h                       }<BR>NoPSV2:<BR><BR></nobr></P>
<P>The restores of <b>gp</b> after the function call are pointless, because the next function call is going to destroy it anyway. This is an actual compiler error; its optimizer should have noticed that <b>gp</b> is not read before it is rewritten.</P>
<P></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_hwndView = NULL;<BR>        m_fHandsOff = FALSE;<BR>71779c60   {          ld4      r30 = [r35]                // r30 = this-&gt;bitfield<BR>71779c64              adds     r31 = 0120h, r32           // r31 = &amp;m_hwndView<BR>71779c68              adds     r33 = 0108h, r32 ;;       }// r33 = &amp;m_pcache<BR>71779c70   {          ld8      r42 = [r33]                // r42 = m_pcache<BR>71779c74              st4      [r31] = r0, 04h            // [r31] = NULL, r31 += 4<BR>71779c78              and      r30 = -2, r30 ;;          }// r30 = r30 &amp; ~-2 (clear bit)<BR>71779c80   {          st4      [r31] = r0                 // [r31] = NULL (other half)<BR>71779c84              st4      [r35] = r30                // bitfield = r30<BR><BR></nobr></P>
<P>The compiler is making additional errors. It splits the m_hwndView into two parts, storing the NULL two DWORDs at a time instead of as a single 64-bit store. The compiler thinks that the m_hwndView member is unaligned so it has to split the store. So you now get to see a postincremented store.</P>
<P></P>
<P><b>"st [dest] = src, n" is a post-incremented store.</b></P>
<P>The "and r30 = -2, r30" clears the bottom bit.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        if (m_pcache) {<BR>71779c88              cmp.eq   p14, p15 = r0, r42        }// m_pcache == NULL?<BR>71779c90   {          nop.b    00h<BR>71779c94              nop.b    00h<BR>71779c98     (p14)    br.cond.dpnt.few  $+090h ;;        }// Y: Jump to NoCache<BR><BR></nobr></P>
<P>The <b>r42</b> register was set up while you were clearing bits in the previous block of code.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            GlobalFree(m_pcache);<BR>71779ca0   {          addl     r31 = -2029288, gp ;;      // r31 = &amp;__imp__GlobalFree<BR>71779ca4              ld8      r30 = [r31]                // r30 = &amp;GlobalFree<BR>71779ca8              nop.i    00h ;;                    }<BR>71779cb0   {          ld8      r29 = [r30], 08h ;;        // r29 = .GlobalFree<BR>71779cb4              ld8      gp = [r30]                 // gp  = gp.GlobalFree<BR>71779cb8              mov      b6 = r29, $+0x0           }// b6  = .GlobalFree<BR>71779cc0   {          nop.m    00h<BR>71779cc4              nop.f    00h<BR>71779cc8              br.call.dptk.many  rp = b6 ;;      }// call .GlobalFree<BR><BR></nobr></P>
<P>Recall that <b>r42</b> already contains the value of m_pcache.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>            m_pcache = NULL;<BR>        }<BR>71779cd0   {          st1      [r33] = r0, 01h            // [r33] = 0, r33++<BR>71779cd4              or       gp = r41, r0               // restore gp after call<BR>71779cd8              nop.b    00h ;;                    }<BR>71779ce0   {          st1      [r33] = r0, 01h ;;         // [r33] = 0, r33++<BR>71779ce4              st1      [r33] = r0, 01h            // [r33] = 0, r33++<BR>71779ce8              nop.i    00h ;;                    }<BR>71779cf0   {          st1      [r33] = r0, 01h ;;         // [r33] = 0, r33++<BR>71779cf4              st1      [r33] = r0, 01h            // [r33] = 0, r33++<BR>71779cf8              nop.i    00h ;;                    }<BR>71779d00   {          st1      [r33] = r0, 01h ;;         // [r33] = 0, r33++<BR>71779d04              st1      [r33] = r0, 01h            // [r33] = 0, r33++<BR>71779d08              nop.i    00h ;;                    }<BR>71779d10   {          st1      [r33] = r0                 // [r33] = 0<BR>71779d14              nop.f    00h<BR>71779d18              nop.b    00h                       }<BR>NoCache:<BR><BR></nobr></P>
<P>More compiler errors.   The compiler assumes that m_pcache is unaligned so it has to zero it out by writing 8 bytes, one at a time, even though it loaded the value at address 71779c70, assuming the address was aligned.</P>
<P></P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>        m_psb-&gt;EnableModelessSB(TRUE);<BR>71779d20   {          ld8      r42 = [r36]                // r42 = this-&gt;m_psb<BR>71779d24              addl     r43 = 01h, r0              // r43 = TRUE<BR>71779d28              nop.b    00h ;;                    }<BR>71779d30   {          ld8      r31 = [r42] ;;             // r31 = this-&gt;m_psb.vtbl<BR>71779d34              adds     r31 = 048h, r31            // r31 = &amp;vtl.EnableModeless<BR>71779d38              nop.i    00h ;;                    }<BR>71779d40   {          ld8      r30 = [r31] ;;             // r30 = &amp;EnableModeless<BR>71779d44              ld8      r29 = [r30], 08h           // r29 = .EnableModeless<BR>71779d48              nop.i    00h ;;                    }<BR>71779d50   {          ld8      gp = [r30]                 // gp  = gp.EnableModeless<BR>71779d54              mov      b6 = r29, $+0x0            // b6  = .EnableModeless<BR>71779d58              br.call.dptk.many  rp = b6 ;;      }// call .EnableModeless<BR>71779d60   {          or       gp = r41, r0               // restore gp after call<BR>        CancelPendingActions();<BR>    }<BR>71779d64              adds     r42 = -40, r32            // r42 = (CUserView*)this<BR>71779d68              br.call.sptk.many  rp = $-15424 ;;  } // call .CancelPendingActions<BR>NoPSV:<BR><BR></nobr></P>
<P>This is a direct call rather than an imported function or a virtual method call. Notice that you did not have to set up the <b>gp</b> register, because <b>CancelPendingActions</b> was not a virtual method. Thus, you know that it resides in your own DLL and, therefore, its <b>gp</b> is equal to your <b>gp</b>. It also means that you do not need to restore <b>gp</b> after the call.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    ReleaseAndNull(&amp;_psf);<BR>71779d70   {          addl     r31 = -2025856, gp         // r31 = &amp;__imp__ReleaseAndNull<BR>71779d74              adds     r42 = 0118h, r32           // r42 = &amp;this-&gt;_psf<BR>71779d78              nop.b    00h ;;                    }<BR>71779d80   {          ld8      r30 = [r31] ;;             // r30 = &amp;ReleaseAndNull<BR>71779d84              ld8      r29 = [r30], 08h           // r29 = .ReleaseAndNull<BR>71779d88              nop.i    00h ;;                    }<BR>71779d90   {          ld8      gp = [r30]                 // gp  = gp.ReleaseAndNull<BR>71779d94              mov      b6 = r29, $+0x0            // b6  = .ReleaseAndNull<BR>71779d98              br.call.dptk.many  rp = b6 ;;      }// call .ReleaseAndNull<BR>71779da0   {          or       gp = r41, r0               // restore gp after call<BR>    if (fViewObjectChanged)<BR>        NotifyViewClients(DVASPECT_CONTENT, -1);<BR>71779da4              cmp4.eq  p14, p15 = r0, r37         // r36 (fViewObjectChanged) == FALSE?<BR>71779da8     (p14)    br.cond.dpnt.few  $+060h ;;        }// Y: Jump to NoChange<BR>71779db0   {          adds     r42 = -40, r32             // r42 = (CBaseBrowser*)this<BR>71779db4              addl     r44 = -1, r0               // r44 = -1<BR>71779db8              addl     r43 = 01h, r0 ;;          }// r43 = 1 = DVASPECT_CONTENT<BR>71779dc0   {          ld8      r31 = [r42] ;;             // r31 = this.vtbl<BR>71779dc4              adds     r31 = 048h, r31            // r31 = &amp;vtbl.NotifyViewClients<BR>71779dc8              nop.i    00h ;;                    }<BR>71779dd0   {          ld8      r30 = [r31] ;;             // r30 = &amp;NotifyViewClients<BR>71779dd4              ld8      r29 = [r30], 08h           // r29 = .NotifyViewClients<BR>71779dd8              nop.i    00h ;;                    }<BR>71779de0   {          ld8      gp = [r30]                 // gp  = gp.NotifyViewClients<BR>71779de4              mov      b6 = r29, $+0x0            // b6  = .NotifyViewClients<BR>71779de8              br.call.dptk.many  rp = b6 ;;      }// call .NotifyViewClients<BR>71779df0   {          or       gp = r41, r0               // restore gp after call<BR>71779df4              nop.f    00h<BR>71779df8              nop.b    00h                       }<BR>NoChange:<BR>    if (m_pszTitle) {<BR>        LocalFree(m_pszTitle);<BR>        m_pszTitle = NULL;<BR>    }<BR>71779e00   {          adds     r33 = 0128h, r32 ;;        // r33 = &amp;this-&gt;m_pszTitle<BR>71779e04              ld8      r42 = [r33]                // r42 = this-&gt;m_pszTitle<BR>71779e08              nop.i    00h ;;                    }<BR>71779e10   {          cmp.eq   p14, p15 = r0, r42         // r42 == NULL?<BR>71779e14              nop.f    00h<BR>71779e18     (p14)    br.cond.dpnt.few  $+050h ;;        }// Y: Jump to NoTitle<BR>71779e20   {          addl     r31 = -2029752, gp ;;      // r31 = &amp;__imp__LocalFree<BR>71779e24              ld8      r30 = [r31]                // r30 = &amp;LocalFree<BR>71779e28              nop.i    00h ;;                    }<BR>71779e30   {          ld8      r29 = [r30], 08h ;;        // r29 = .LocalFree<BR>71779e34              ld8      gp = [r30]                 // gp  = gp.LocalFree<BR>71779e38              mov      b6 = r29, $+0x0           }// b6  = .LocalFree<BR>71779e40   {          nop.m    00h<BR>71779e44              nop.f    00h<BR>71779e48              br.call.dptk.many  rp = b6 ;;      }// call .LocalFree<BR>71779e50   {          st8      [r33] = r0                 // this-&gt;m_pszTitle = 0<BR>71779e54              or       gp = r41, r0               // restore gp after call<BR>71779e58              nop.b    00h ;;                    }<BR>NoTitle:<BR><BR></nobr></P>
<P>Nothing new in the following.</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>    SetRect(&amp;m_rcBounds, 0, 0, 0, 0);<BR>71779e60   {          addl     r31 = -2024936, gp         // r31 = &amp;__imp__SetRect<BR>71779e64              addl     r46 = 00h, r0              // r46 = 0<BR>71779e68              addl     r45 = 00h, r0             }// r45 = 0<BR>71779e70   {          addl     r44 = 00h, r0 ;;           // r44 = 0<BR>71779e74              ld8      r30 = [r31]                // r30 = &amp;SetRect<BR>71779e78              addl     r43 = 00h, r0             }// r43 = 0<BR>71779e80   {          adds     r42 = 0208h, r32 ;;        // r42 = &amp;this-&gt;m_rcBounds<BR>71779e84              ld8      r29 = [r30], 08h           // r29 = .SetRect<BR>71779e88              nop.i    00h ;;                    }<BR>71779e90   {          ld8      gp = [r30]                 // gp  = gp.SetRect<BR>71779e94              mov      b6 = r29, $+0x0            // b6  = .SetRect<BR>71779e98              br.call.dptk.many  rp = b6 ;;      }// call .SetRect<BR>71779ea0   {          or       gp = r41, r0               // restore gp after call<BR>71779ea4              nop.f    00h<BR>71779ea8              nop.b    00h                       }<BR>    return S_OK;<BR>ReturnSOK:<BR>71779eb0   {          or       ret0 = r0, r0<BR><BR></nobr></P>
<P>Finally, you get to set the return value:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>}<BR>71779eb4              mov      rp = r38, $+0x0            // restore return address<BR>71779eb8              adds     sp = 020h, sp ;;          }// clean up stack<BR>71779ec0   {          nop.m    00h<BR>71779ec4              mov      pr = r40, -2 ;;            // restore predicate registers<BR>71779ec8              mov.i    ar.pfs = r39              }// clean up stack frame<BR>71779ed0   {          nop.m    00h<BR>71779ed4              nop.f    00h<BR>71779ed8              br.ret.sptk.many  rp ;;            }// return to caller<BR><BR></nobr></P>
<P>And this is the function epilogue.</P><B></B><UL type="disc">
<LI>You restore the <b>rp</b> register to contain your return address that you saved in the prologue.</LI>
<LI>You clean up the stack.</LI>
<LI>You restore the predicate registers.</LI>
<LI>You restore the original stack frame with the value you placed in <b>r39</b> when you created your stack frame.</LI>
<LI>Finally, you return to your caller through the <b>rp</b> register.</LI>
</UL>
<P></P>
<P></P>
<P></P>
<DIV style="display:yes"></DIV>
<DIV CLASS="footer"><br><A href="dbglegal.htm">© 2009 Microsoft Corporation</A><br><A href="mailto:windbgfb@microsoft.com?subject=documentation feedback [Debugger]: Annotated Itanium Disassembly RELEASE: (December 09, 2009)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AThe WDK team uses the feedback submitted to improve the WDK documentation. We do not use your e-mail address for any other purpose. We will remove your e-mail address from our system after the issue you are reporting has been resolved. While we are working to resolve this issue, we may send you an e-mail message to request more information about your feedback. After the issues have been addressed, we may send you an e-mail message to let you know that your feedback has been addressed.%0A%0AFor more information about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx.
              ">Send feedback on this topic</A><br>Debugging Tools for Windows<br>December 09, 2009<br></DIV>
</Body>
</HTML>
