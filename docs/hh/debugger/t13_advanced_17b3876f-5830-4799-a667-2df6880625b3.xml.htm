<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/MSHelp">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>Manually Walking a Stack</TITLE>
<META NAME="ms.locale" content="en-us">
<META NAME="DESCRIPTION" CONTENT="Debugger, Debugger, Design Guide, Manually Walking a Stack"><xml><MSHelp:Keyword Index="A" Term="t13_advanced_17b3876f-5830-4799-a667-2df6880625b3.xml"/>
<META NAME="MS-HKWD" CONTENT="stack trace, walking the stack manually">
<META NAME="MS-HKWD" CONTENT="walking the stack"></xml><LINK REL="stylesheet" type="text/css" href="backsdk4.css"><SCRIPT src="langref.js"></SCRIPT><style>dd {margin-bottom:0em; margin-left:1.9em; }</style>
<style>.divclass {behavior:url(#default#savehistory);}</style>
<META NAME="save" CONTENT="history">
</HEAD>
<Body topmargin="0">
<DIV STYLE="display:none;"></DIV>
<DIV STYLE="display:none;"></DIV>
<TABLE CLASS="buttonbarshade" CELLSPACING="0" border="0"><TR><TD NOWRAP="true"> </TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING="0">
<TR ID="hdr">
<TD NOWRAP="true" CLASS="runninghead">Debugging Tools for Windows</TD>
</TR>
</TABLE>
<H1><A NAME="t13_advanced_17b3876f-5830-4799-a667-2df6880625b3.xml"></A>Manually Walking a Stack</H1>
<P>In some cases, the stack trace function will fail in the debugger. This can be caused by a call to an invalid address that caused the debugger to lose the location of the return address; or you may have come across a stack pointer for which you cannot directly get a stack trace; or there could be some other debugger problem. In any case, being able to manually walk a stack is often valuable.</P>
<P>The basic concept is fairly simple: dump out the stack pointer, find out where the modules are loaded, find possible function addresses, and verify by checking to see if each possible stack entry makes a call to the next. </P>
<P>Before going through an example, it is important to note that the <a href="r17_cmds_i_58e69e42-fcda-4972-9358-60ab7a6e1def.xml.htm"><b>kb (Display Stack Backtrace)</b></a> command has an additional feature on Intel systems. By doing a kb=[ebp] [eip] [esp], the debugger will display the stack trace for the frame with the given values for base pointer, instruction pointer, and stack pointer, respectively.</P>
<P>For the example, a failure that actually gives a stack trace is used so the results can be checked at the end.</P>
<P>The first step is to find out what modules are loaded where. This is accomplished with the <a href="r18_cmds_s_717feb00-25c4-4911-be94-52c11698f782.xml.htm"><b>x (Examine Symbols)</b></a> command (some symbols are edited out for reasons of length):</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>kd&gt; <b>x *!</b> <BR>start    end        module name<BR>77f70000 77fb8000   ntdll     (C:\debug\ntdll.dll, \\ntstress\symbols\dll\ntdll.DBG)<BR>80010000 80012320   Aha154x   (load from Aha154x.sys deferred)<BR>80013000 8001aa60   SCSIPORT  (load from SCSIPORT.SYS deferred)<BR>8001b000 8001fba0   Scsidisk  (load from Scsidisk.sys deferred)<BR><BR>80100000 801b7b40   NT        (ntoskrnl.exe, \\ntstress\symbols\exe\ntoskrnl.DBG)<BR>802f0000 8033c000   Ntfs      (load from Ntfs.sys deferred)<BR>80400000 8040c000   hal       (load from hal.dll deferred)<BR>fe4c0000 fe4c38c0   vga       (load from vga.sys deferred)<BR>fe4d0000 fe4d3e60   VIDEOPRT  (load from VIDEOPRT.SYS deferred)<BR>fe4e0000 fe4f0e40   ati       (load from ati.SYS deferred)<BR>fe500000 fe5057a0   Msfs      (load from Msfs.SYS deferred)<BR>fe510000 fe519560   Npfs      (load from Npfs.SYS deferred)<BR><BR>fe520000 fe521f60   ndistapi  (load from ndistapi.sys deferred)<BR>fe530000 fe54ed20   Fastfat   (load from Fastfat.SYS deferred)<BR>fe5603e0 fe575360   NDIS      (NDIS.SYS, \\ntstress\symbols\SYS\NDIS.DBG)<BR>fe580000 fe585920   elnkii    (elnkii.sys, \\ntstress\symbols\sys\elnkii.DBG)<BR>fe590000 fe59b8a0   ndiswan   (load from ndiswan.sys deferred)<BR>fe5a0000 fe5b7c40   nbf       (load from nbf.sys deferred)<BR>fe5c0000 fe5c1b40   TDI       (load from TDI.SYS deferred)<BR>fe5d0000 fe5dd580   nwlnkipx  (load from nwlnkipx.sys deferred)<BR><BR>fe5e0000 fe5ee220   nwlnknb   (load from nwlnknb.sys deferred)<BR>fe5f0000 fe5fb320   afd       (load from afd.sys deferred)<BR>fe610000 fe62bf00   tcpip     (load from tcpip.sys deferred)<BR>fe630000 fe648600   netbt     (load from netbt.sys deferred)<BR>fe650000 fe6572a0   netbios   (load from netbios.sys deferred)<BR>fe660000 fe660000   Parport   (load from Parport.SYS deferred)<BR>fe670000 fe670000   Parallel  (load from Parallel.SYS deferred)<BR>fe680000 fe6bcf20   rdr       (rdr.sys, \\ntstress\symbols\sys\rdr.DBG)<BR><BR>fe6c0000 fe6f0920   srv       (load from srv.sys deferred) <BR></nobr></P>
<P>The second step is dumping out the stack pointer (<b>esp</b> on an x86, <b>sp</b> on an Intel Itanium) to look for addresses in the modules given by the <b>x *! </b>command:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>kd&gt; <b>dd esp</b> <BR>fe4cc97c  80136039 00000270 00000000 00000000<BR>fe4cc98c  fe682ae4 801036fe 00000000 fe68f57a<BR>fe4cc99c  fe682a78 ffb5b030 00000000 00000000<BR>fe4cc9ac  ff680e08 801036fe 00000000 00000000<BR>fe4cc9bc  fe6a1198 00000001 fe4cca78 ffae9d98<BR><BR>fe4cc9cc  02000901 fe4cca68 ffb50030 ff680e08<BR>fe4cc9dc  ffa449a8 8011c901 fe4cca78 00000000<BR>fe4cc9ec  80127797 80110008 00000246 fe6a1430<BR><BR>kd&gt; <b>dd</b> <BR>fe4cc9fc  00000270 fe6a10ae 00000270 ffa44abc<BR>fe4cca0c  ffa449a8 ff680e08 fe6b2c04 ff680e08<BR>fe4cca1c  ffa449a8 e12820c8 e1235308 ffa449a8<BR>fe4cca2c  fe685968 ff680e08 e1235308 ffa449a8<BR>fe4cca3c  ffb0ad48 ffb0ad38 00100000 ffb0ad38<BR>fe4cca4c  00000000 ffa44a84 e1235308 0000000a<BR>fe4cca5c  c00000d6 00000000 004ccb28 fe4ccbc4<BR><BR>fe4cca6c  fe680ba4 fe682050 00000000 fe4ccbd4 <BR></nobr></P>
<P>To determine which values are likely function addresses and which are parameters or saved registers, the first thing to consider is what the different types of information look like on the stack. Most integers are going to be smaller value, which means they will be mostly zeros when displayed as DWORDs (like 0x00000270). Most pointers to local addresses will be near the stack pointer (like fe4cca78). Status codes usually begin with a c (c00000d6). Unicode and ASCII strings can be identified by the fact that each character will be in the range of 20-7f. (In KD, the <a href="r16_cmds_c_eddd6afa-a4e9-49c7-8752-7005aca29a84.xml.htm"><b>dc (Display Memory)</b></a> command will show the characters on the right.) Most importantly, the function addresses will be in the range listed by <b>x *!</b>.</P>
<P>Notice that all modules listed are in the ranges of 77f70000 to 8040c000 and fe4c0000 to fe6f0920. Based on these ranges, the possible function addresses in the preceding list are: 80136039, 801036fe (listed twice, so more likely a parameter), fe682ae4, fe68f57a, fe682a78, fe6a1198, 8011c901, 80127797, 80110008, fe6a1430, fe6a10ae, fe6b2c04, fe685968, fe680ba4, and fe682050. Investigate these locations by using an <a href="r17_cmds_i_9b6813c3-7868-43c4-94fb-42e3488dd53a.xml.htm"><b>ln (List Nearest Symbols)</b></a> command for each address:    </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>kd&gt; <b>ln 80136039</b> <BR>(80136039)   NT!_KiServiceExit+0x1e  |  (80136039)   NT!_KiServiceExit2-0x177<BR>kd&gt; <b>ln fe682ae4</b> <BR>(fe682ae4)   rdr!_RdrSectionInfo+0x2c | (fe682ae4)   rdr!_RdrFcbReferenceLock-0xb4<BR>kd&gt; <b>ln 801036fe</b> <BR>(801036fe)   NT!_KeWaitForSingleObject | (801036fe)   NT!_MmProbeAndLockPages-0x2f8<BR>kd&gt; <b>ln fe68f57a</b> <BR>(fe68f57a)   rdr!_RdrDereferenceDiscardableCode+0xb4  <BR>                         (fe68f57a)   rdr!_RdrUninitializeDiscardableCode-0xa<BR>kd&gt; <b>ln fe682a78</b> <BR>(fe682a78)   rdr!_RdrDiscardableCodeLock | (fe682a78) rdr!_RdrDiscardableCodeTimeout-0x38<BR><BR>kd&gt; <b>ln fe6a1198</b> <BR>(fe6a1198)   rdr!_SubmitTdiRequest+0xae | (fe6a1198)   rdr!_RdrTdiAssociateAddress-0xc<BR>kd&gt; <b>ln 8011c901</b> <BR>(8011c901)   NT!_KeSuspendThread+0x13 | (8011c901)   NT!_FsRtlCheckLockForReadAccess-0x55<BR>kd&gt; <b>ln 80127797</b> <BR>(80127797)   NT!_ZwCloseObjectAuditAlarm+0x7 | (80127797)   NT!_ZwCompleteConnectPort-0x9<BR>kd&gt; <b>ln 80110008</b> <BR>(80110008)   NT!_KeWaitForMultipleObjects+0x27c | (80110008) NT!_FsRtlLookupMcbEntry-0x164<BR>kd&gt; <b>ln fe6a1430</b> <BR>(fe6a1430)   rdr!_RdrTdiCloseConnection+0xa | (fe6a1430)   rdr!_RdrDoTdiConnect-0x4<BR><BR>kd&gt; <b>ln fe6a10ae</b> <BR>(fe6a10ae)   rdr!_RdrTdiDisconnect+0x56 | (fe6a10ae)   rdr!_SubmitTdiRequest-0x3c<BR>kd&gt; <b>ln fe6b2c04</b> <BR>(fe6b2c04)   rdr!_CleanupTransportConnection+0x64 | (fe6b2c04)rdr!_RdrReferenceServer-0x20<BR>kd&gt; <b>ln fe685968</b> <BR>(fe685968)   rdr!_RdrReconnectConnection+0x1b6<BR>                        (fe685968)   rdr!_RdrInvalidateServerConnections-0x32<BR>kd&gt; <b>ln fe682050</b> <BR>(fe682050)   rdr!__strnicmp+0xaa  |  (fe682050)   rdr!_BackPackSpinLock-0xa10 <BR></nobr></P>
<P>As noted before, 801036fe is not likely to be part of the stack trace as it is listed twice. If the return addresses have an offset of zero, they can be ignored (you cannot return to the beginning of a function). Based on this information, the stack trace is revealed to be:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>NT!_KiServiceExit+0x1e<BR>rdr!_RdrSectionInfo+0x2c<BR>rdr!_RdrDereferenceDiscardableCode+0xb4  <BR>rdr!_SubmitTdiRequest+0xae<BR>NT!_KeSuspendThread+0x13<BR>NT!_ZwCloseObjectAuditAlarm+0x7<BR>NT!_KeWaitForMultipleObjects+0x27c<BR>rdr!_RdrTdiCloseConnection+0xa<BR>rdr!_RdrTdiDisconnect+0x56<BR>rdr!_CleanupTransportConnection+0x64<BR>rdr!_RdrReconnectConnection+0x1b6<BR>rdr!__strnicmp+0xaa <BR></nobr></P>
<P>To verify each symbol, unassemble immediately before the return address specified to see if it does a call to the function above it. To reduce length, the following is edited (the offsets used were found by trial and error):</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>kd&gt; <b>u 80136039-2 l1</b>      //  looks ok, its a call<BR>NT!_KiServiceExit+0x1c:<BR>80136037 ffd3             call    ebx<BR>kd&gt; <b>u fe682ae4-2 l1 </b>     //  paged out (all zeroes) unknown<BR>rdr!_RdrSectionInfo+0x2a:<BR>fe682ae2 0000             add     [eax],al<BR>kd&gt; <b>u fe68f57a-6 l1</b>      //  looks ok, its a call, but not anything above<BR>rdr!_RdrDereferenceDiscardableCode+0xae:<BR>fe68f574 ff15203568fe     call dword ptr [rdr!__imp__ExReleaseResourceForThreadLite]<BR>kd&gt; <b>u fe682a78-6 l1</b>      //  paged out (all zeroes) unknown<BR><BR>rdr!_DiscCodeInitialized+0x2:<BR>fe682a72 0000             add     [eax],al<BR>kd&gt; <b>u  fe6a1198-5 l1 </b>     //  looks good, call to something above<BR>rdr!_SubmitTdiRequest+0xa9:<BR>fe6a1193 e82ee3feff       call  rdr!_RdrDereferenceDiscardableCode (fe68f4c6)<BR>kd&gt; <b>u 8011c901-2 l1</b>      //  not good, its a jump in the function<BR>NT!_KeSuspendThread+0x11:<BR>8011c8ff 7424             jz      NT!_KeSuspendThread+0x37 (8011c925)<BR>kd&gt; <b>u 80127797-2 l1</b>      //  looks good, an int 2e -&gt; KiServiceExit<BR><BR>NT!_ZwCloseObjectAuditAlarm+0x5:<BR>80127795 cd2e             int     2e<BR>kd&gt;<b> u 80110008-2 l1</b>      //  not good, its a test instruction not a call<BR>NT!_KeWaitForMultipleObjects+0x27a:<BR>80110006 85c9             test    ecx,ecx<BR>kd&gt; <b>u 80110008-5 l1</b>      //  paged out (all zeroes) unknown<BR>NT!_KeWaitForMultipleObjects+0x277:<BR>80110003 0000             add     [eax],al<BR>kd&gt; <b>u fe6a1430-6 l1</b>      //  looks good its a call to ZwClose...<BR>rdr!_RdrTdiCloseConnection+0x4:<BR>fe6a142a ff15f83468fe     call    dword ptr [rdr!__imp__ZwClose (fe6834f8)]<BR><BR>kd&gt; <b>u fe6a10ae-2 l1  </b>    //  paged out (all zeroes) unknown<BR>rdr!_RdrTdiDisconnect+0x54:<BR>fe6a10ac 0000             add     [eax],al<BR>kd&gt; <b>u  fe6b2c04-5 l1 </b>     //  looks good, call to something above<BR>rdr!_CleanupTransportConnection+0x5f:<BR>fe6b2bff e854e4feff       call    rdr!_RdrTdiDisconnect (fe6a1058)<BR>kd&gt; <b>u fe685968-5 l1</b>      //  looks good, call to immediately above<BR>rdr!_RdrReconnectConnection+0x1b1:<BR>fe685963 e838d20200       call    rdr!_CleanupTransportConnection (fe6b2ba0)<BR><BR>kd&gt; <b>u fe682050-2 l1</b>      //  paged out (all zeroes) unknown<BR>rdr!__strnicmp+0xa8:<BR>fe68204e 0000             add     [eax],al <BR></nobr></P>
<P>Based on this, it appears that <b>RdrReconnectConnection</b> called <b>RdrCleanupTransportConnection</b>, to <b>RdrTdiDisconnect</b>, to <b>ZwCloseObjectAuditAlarm</b>, to <b>KiSystemServiceExit</b>. The other functions on the stack are probably leftover portions of previously active stacks. </P>
<P>In this case, the stack trace worked properly. Following is the actual stack trace to check the answer:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>kd&gt; <b>k</b> <BR>ChildEBP RetAddr<BR>fe4cc978 80136039 NT!_NtClose+0xd<BR>fe4cc978 80127797 NT!_KiServiceExit+0x1e<BR><BR>fe4cc9f4 fe6a1430 NT!_ZwCloseObjectAuditAlarm+0x7<BR>fe4cca10 fe6b2c04 rdr!_RdrTdiCloseConnection+0xa<BR>fe4cca28 fe685968 rdr!_CleanupTransportConnection+0x64<BR>fe4cca78 fe688157 rdr!_RdrReconnectConnection+0x1b6<BR>fe4ccbd4 80106b1e rdr!_RdrFsdCreate+0x45b<BR>fe4ccbe8 8014b289 NT!IofCallDriver+0x38<BR>fe4ccc98 8014decd NT!_IopParseDevice+0x693<BR>fe4ccd08 8014d6d2 NT!_ObpLookupObjectName+0x487<BR>fe4ccde4 8014d3ad NT!_ObOpenObjectByName+0xa2<BR>fe4cce90 8016660d NT!_IoCreateFile+0x433<BR>fe4cced0 80136039 NT!_NtCreateFile+0x2d <BR></nobr></P>
<P>The first entry was the current location based on the stack trace, but otherwise, the stack was correct up to the point where <b>RdrReconnectConnection</b> was called. The same process could have been used to trace the entire stack. For a more exact method of manual stack walking, you would need to unassemble each potential function and follow each <b>push</b> and <b>pop </b>to identify each DWORD on the stack.</P>
<P></P>
<DIV style="display:yes"></DIV>
<DIV CLASS="footer"><br><A href="dbglegal.htm">© 2009 Microsoft Corporation</A><br><A href="mailto:windbgfb@microsoft.com?subject=documentation feedback [Debugger]: Manually Walking a Stack RELEASE: (December 09, 2009)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AThe WDK team uses the feedback submitted to improve the WDK documentation. We do not use your e-mail address for any other purpose. We will remove your e-mail address from our system after the issue you are reporting has been resolved. While we are working to resolve this issue, we may send you an e-mail message to request more information about your feedback. After the issues have been addressed, we may send you an e-mail message to let you know that your feedback has been addressed.%0A%0AFor more information about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx.
              ">Send feedback on this topic</A><br>Debugging Tools for Windows<br>December 09, 2009<br></DIV>
</Body>
</HTML>
