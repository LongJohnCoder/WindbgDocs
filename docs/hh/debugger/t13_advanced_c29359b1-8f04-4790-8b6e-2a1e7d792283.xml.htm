<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/MSHelp">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>Debugging a Stack Overflow</TITLE>
<META NAME="ms.locale" content="en-us">
<META NAME="DESCRIPTION" CONTENT="Debugger, Debugger, Design Guide, Debugging a Stack Overflow"><xml><MSHelp:Keyword Index="A" Term="t13_advanced_c29359b1-8f04-4790-8b6e-2a1e7d792283.xml"/>
<META NAME="MS-HKWD" CONTENT="stack overflow">
<META NAME="MS-HKWD" CONTENT="call stack, debugging a stack overflow"></xml><LINK REL="stylesheet" type="text/css" href="backsdk4.css"><SCRIPT src="langref.js"></SCRIPT><style>dd {margin-bottom:0em; margin-left:1.9em; }</style>
<style>.divclass {behavior:url(#default#savehistory);}</style>
<META NAME="save" CONTENT="history">
</HEAD>
<Body topmargin="0">
<DIV STYLE="display:none;"></DIV>
<DIV STYLE="display:none;"></DIV>
<TABLE CLASS="buttonbarshade" CELLSPACING="0" border="0"><TR><TD NOWRAP="true"> </TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING="0">
<TR ID="hdr">
<TD NOWRAP="true" CLASS="runninghead">Debugging Tools for Windows</TD>
</TR>
</TABLE>
<H1><A NAME="t13_advanced_c29359b1-8f04-4790-8b6e-2a1e7d792283.xml"></A>Debugging a Stack Overflow</H1>
<P>A <i>stack overflow</i> is an error that user-mode threads can encounter. There are three possible causes for this error:</P><B></B><UL type="disc">
<LI>A thread uses the entire stack reserved for it. This is often caused by infinite recursion.</LI>
<LI>A thread cannot extend the stack because the page file is maxed out, and therefore no additional pages can be committed to extend the stack.   </LI>
<LI>A thread cannot extend the stack because the system is within the brief period used to extend the page file.   </LI>
</UL>
<P></P>
<P>Here is an example of how to debug this error. In this example, NTSD is running on the same computer as the target application and is redirecting its output to KD on the host computer. See <a href="r05_use_start_9fcf66d7-d72a-4b94-a1e6-e65a95e688f7.xml.htm">Controlling the User-Mode Debugger from the Kernel Debugger</a> for details.</P>
<P>The first step is see what event caused the debugger to break in: </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>.lastevent</b> <BR>Last event: Exception C00000FD, second chance <BR></nobr></P>
<P>You can look up exception code 0xC00000FD in <i>ntstatus.h</i>, which can be found in the Microsoft Windows SDK and the Windows Driver Kit (WDK). This exception code is STATUS_STACK_OVERFLOW.</P>
<P>To double-check that the stack overflowed, you can use the <a href="r17_cmds_i_58e69e42-fcda-4972-9358-60ab7a6e1def.xml.htm"><b>k (Display Stack Backtrace)</b></a> command:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>k</b> <BR>ChildEBP RetAddr<BR>009fdd0c 71a32520 COMCTL32!_chkstk+0x25<BR>009fde78 77cf8290 COMCTL32!ListView_WndProc+0x4c4<BR>009fde98 77cfd634 USER32!_InternalCallWinProc+0x18<BR>009fdf00 77cd55e9 USER32!UserCallWinProcCheckWow+0x17f<BR>009fdf3c 77cd63b2 USER32!SendMessageWorker+0x4a3<BR>009fdf5c 71a45b30 USER32!SendMessageW+0x44<BR>009fdfec 71a45bb0 COMCTL32!CCSendNotify+0xc0e<BR>009fdffc 71a1d688 COMCTL32!CICustomDrawNotify+0x2a<BR>009fe074 71a1db30 COMCTL32!Header_Draw+0x63<BR>009fe0d0 71a1f196 COMCTL32!Header_OnPaint+0x3f<BR>009fe128 77cf8290 COMCTL32!Header_WndProc+0x4e2<BR>009fe148 77cfd634 USER32!_InternalCallWinProc+0x18<BR>009fe1b0 77cd4490 USER32!UserCallWinProcCheckWow+0x17f<BR>009fe1d8 77cd46c8 USER32!DispatchClientMessage+0x31<BR>009fe200 77f7bb3f USER32!__fnDWORD+0x22<BR>009fe220 77cd445e ntdll!_KiUserCallbackDispatcher+0x13<BR>009fe27c 77cfd634 USER32!DispatchMessageWorker+0x3bc<BR>009fe2e4 009fe4a8 USER32!UserCallWinProcCheckWow+0x17f<BR>00000000 00000000 0x9fe4a8 <BR></nobr></P>
<P>The target thread has broken into <b>COMCTL32!_chkstk</b>, which indicates a stack problem.   </P>
<P>Now you should investigate the stack usage of the target process. The process has multiple threads, but the important one is the one that caused the overflow, so identify this thread first:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>~*k</b><BR><BR>   0  id: 570.574   Suspend: 1 Teb 7ffde000 Unfrozen<BR>   .....<BR><BR>   1  id: 570.590   Suspend: 1 Teb 7ffdd000 Unfrozen<BR>   .....<BR><BR>. 2  id: 570.598   Suspend: 1 <b>Teb 7ffdc000</b> Unfrozen<BR>ChildEBP RetAddr<BR>009fdd0c 71a32520 COMCTL32!_chkstk+0x25  <BR>.....<BR><BR>   3  id: 570.760   Suspend: 1 Teb 7ffdb000 Unfrozen <BR></nobr></P>
<P>Now you need to investigate thread 2. The period at the left of this line indicates that this is the current thread.</P>
<P>The stack information is contained in the TEB (Thread Environment Block) at 0x7FFDC000. The easiest way to list it is using <a href="r25_exts_general_he_8f21ff4e-e437-4947-8075-37872377efac.xml.htm"><b>!teb</b></a>. However, this requires you to have the proper symbols. For maximum versatility, assume you have no symbols: </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>dd 7ffdc000 L4</b> <BR>7ffdc000   009fdef0 00a00000 009fc000 00000000 <BR></nobr></P>
<P>To interpret this, you need to look up the definition of the TEB data structure. If you had complete symbols, you could use <a href="r16_cmds_c_94727332-6184-4ced-897b-d358ca7c173d.xml.htm"><b>dt TEB</b></a> to do this. But in this case, you will need to look at the <i>ntpsapi.h</i> file in the Microsoft Windows SDK. For Windows XP and later versions of Windows, this file contains the following information:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>typedef struct _TEB {<BR>    NT_TIB <b>NtTib</b>;<BR>    PVOID  EnvironmentPointer;<BR>    CLIENT_ID ClientId;<BR>    PVOID ActiveRpcHandle;<BR>    PVOID ThreadLocalStoragePointer;<BR>    PPEB ProcessEnvironmentBlock;<BR>    ULONG LastErrorValue;<BR>    .....<BR>    PVOID <b>DeallocationStack</b>;<BR>    .....<BR>} TEB;<BR><BR>typedef struct _NT_TIB {<BR>    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;<BR>    PVOID <b>StackBase</b>;<BR>    PVOID <b>StackLimit</b>;<BR>    .....<BR>} NT_TIB; <BR></nobr></P>
<P>This indicates that the second and third DWORDs in the TEB structure point to the bottom and top of the stack, respectively. In this case, these addresses are 0x00A00000 and 0x009FC000. (The stack grows downward in memory.) You can calculate the stack size using the <a href="r15_cmds_a_c6ea44eb-73b8-451d-8054-ded9b17ac2bd.xml.htm"><b>? (Evaluate Expression)</b></a> command:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>? a00000-9fc000</b><BR>Evaluate expression: 16384 = 00004000 <BR></nobr></P>
<P>This shows that the stack size is 16 K. The maximum stack size is stored in the field <b>DeallocationStack</b>. After some calculation, you can determine that this field's offset is 0xE0C.  </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>dd 7ffdc000+e0c L1</b> <BR>7ffdce0c   009c0000 <BR><BR>0:002&gt; <b>? a00000-9c0000</b> <BR>Evaluate expression: 262144 = 00040000 <BR></nobr></P>
<P>This shows that the maximum stack size is 256 K, which means more than adequate stack space is left.</P>
<P>Furthermore, this process looks clean &#8212; it is not in an infinite recursion or exceeding its stack space by using excessively large stack-based data structures.</P>
<P>Now break into KD and look at the overall system memory usage with the <a href="r30_exts_kernel_u_f7bac801-e399-4fab-af3e-ad2c1effce20.xml.htm"><b>!vm</b></a> extension command: </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>.breakin</b> <BR>Break instruction exception - code 80000003 (first chance)<BR>ntoskrnl!_DbgBreakPointWithStatus+4:<BR>80148f9c cc               int     3<BR><BR>kd&gt; <b>!vm</b> <BR><BR>*** Virtual Memory Usage ***<BR>        Physical Memory:     16268   (   65072 Kb)<BR>        Page File: \??\C:\pagefile.sys<BR>           Current:    147456Kb Free Space:     65988Kb<BR>           Minimum:     98304Kb Maximum:       196608Kb<BR>        Available Pages:      2299   (    9196 Kb)<BR>        ResAvail Pages:       4579   (   18316 Kb)<BR>        Locked IO Pages:        93   (     372 Kb)<BR>        Free System PTEs:    42754   (  171016 Kb)<BR>        Free NP PTEs:         5402   (   21608 Kb)<BR>        Free Special NP:       348   (    1392 Kb)<BR>        Modified Pages:        757   (    3028 Kb)<BR><b>        NonPagedPool Usage:    811   (    3244 Kb)</b><BR><b>        NonPagedPool Max:     6252   (   25008 Kb)</b><BR>        PagedPool 0 Usage:    1337   (    5348 Kb)<BR>        PagedPool 1 Usage:     893   (    3572 Kb)<BR>        PagedPool 2 Usage:     362   (    1448 Kb)<BR><b>        PagedPool Usage:      2592   (   10368 Kb)</b><BR><b>        PagedPool Maximum:   13312   (   53248 Kb)</b><BR>        Shared Commit:        3928   (   15712 Kb)<BR>        Special Pool:         1040   (    4160 Kb)<BR>        Shared Process:       3641   (   14564 Kb)<BR>        PagedPool Commit:     2592   (   10368 Kb)<BR>        Driver Commit:         887   (    3548 Kb)<BR><b>        Committed pages:     45882   (  183528 Kb)</b><BR><b>        Commit limit:        50570   (  202280 Kb)</b><BR><BR>        Total Private:       33309   (  133236 Kb)<BR>         ..... <BR></nobr></P>
<P>First, look at nonpaged and paged pool usage. Both are well within limits, so these are not the cause of the problem.</P>
<P>Next, look at the number of committed pages: 183528 out of 202280. This is very close to the limit. Although this display does not show this number to be <i>at</i> the limit, you should keep in mind that while you are performing user-mode debugging, other processes are running on the system. Each time an NTSD command is executed, these other processes are also allocating and freeing memory. That means you do not know exactly what the memory state was like at the time the stack overflow occurred. Given how close the committed page number is to the limit, it is reasonable to conclude that the page file was used up at some point and this caused the stack overflow.</P>
<P>This is not an uncommon occurrence, and the target application cannot really be faulted for this. If it happens frequently, you may want to consider raising the initial stack commitment for the failing application. </P>
<H4>Analyzing a Single Function Call</H4>
<P>It can also be useful to find out exactly how much stack space a certain function call is allocating.</P>
<P>To do this, disassemble the first few instructions and look for the instruction <b>sub esp,</b><I><B>number</B></I>. This moves the stack pointer, effectively reserving <i>number</i> bytes for local data.</P>
<P>Here is an example:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:002&gt; <b>k</b> <BR>ChildEBP RetAddr<BR>009fdd0c 71a32520 COMCTL32!_chkstk+0x25<BR>009fde78 77cf8290 COMCTL32!ListView_WndProc+0x4c4<BR>009fde98 77cfd634 USER32!_InternalCallWinProc+0x18<BR>009fdf00 77cd55e9 USER32!UserCallWinProcCheckWow+0x17f<BR>009fdf3c 77cd63b2 USER32!SendMessageWorker+0x4a3<BR>009fdf5c 71a45b30 USER32!SendMessageW+0x44<BR>009fdfec 71a45bb0 COMCTL32!CCSendNotify+0xc0e<BR>009fdffc 71a1d688 COMCTL32!CICustomDrawNotify+0x2a<BR>009fe074 71a1db30 COMCTL32!Header_Draw+0x63<BR>009fe0d0 71a1f196 COMCTL32!Header_OnPaint+0x3f<BR>009fe128 77cf8290 COMCTL32!Header_WndProc+0x4e2<BR>009fe148 77cfd634 USER32!_InternalCallWinProc+0x18<BR><BR>0:002&gt; <b>u COMCTL32!Header_Draw</b><BR>COMCTL32!Header_Draw :<BR>71a1d625 55               push    ebp<BR>71a1d626 8bec             mov     ebp,esp<BR>71a1d628 83ec58           <b>sub     esp,0x58</b><BR>71a1d62b 53               push    ebx<BR>71a1d62c 8b5d08           mov     ebx,[ebp+0x8]<BR>71a1d62f 56               push    esi<BR>71a1d630 57               push    edi<BR>71a1d631 33f6             xor     esi,esi <BR></nobr></P>
<P>This shows that <b>Header_Draw</b> allocated 0x58 bytes of stack space.</P>
<P></P>
<DIV style="display:yes"></DIV>
<DIV CLASS="footer"><br><A href="dbglegal.htm">© 2009 Microsoft Corporation</A><br><A href="mailto:windbgfb@microsoft.com?subject=documentation feedback [Debugger]: Debugging a Stack Overflow RELEASE: (December 09, 2009)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AThe WDK team uses the feedback submitted to improve the WDK documentation. We do not use your e-mail address for any other purpose. We will remove your e-mail address from our system after the issue you are reporting has been resolved. While we are working to resolve this issue, we may send you an e-mail message to request more information about your feedback. After the issues have been addressed, we may send you an e-mail message to let you know that your feedback has been addressed.%0A%0AFor more information about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx.
              ">Send feedback on this topic</A><br>Debugging Tools for Windows<br>December 09, 2009<br></DIV>
</Body>
</HTML>
