<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><HTML DIR="LTR" xmlns:MSHelp="http://msdn.microsoft.com/MSHelp">
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<TITLE>Debugging a Deadlock</TITLE>
<META NAME="ms.locale" content="en-us">
<META NAME="DESCRIPTION" CONTENT="Debugger, Debugger, Design Guide, Debugging a Deadlock"><xml><MSHelp:Keyword Index="A" Term="t13_advanced_cc933b2b-4388-4b51-9950-d62953991b10.xml"/>
<META NAME="MS-HKWD" CONTENT="deadlocks">
<META NAME="MS-HKWD" CONTENT="thread, no ready threads"></xml><LINK REL="stylesheet" type="text/css" href="backsdk4.css"><SCRIPT src="langref.js"></SCRIPT><style>dd {margin-bottom:0em; margin-left:1.9em; }</style>
<style>.divclass {behavior:url(#default#savehistory);}</style>
<META NAME="save" CONTENT="history">
</HEAD>
<Body topmargin="0">
<DIV STYLE="display:none;"></DIV>
<DIV STYLE="display:none;"></DIV>
<TABLE CLASS="buttonbarshade" CELLSPACING="0" border="0"><TR><TD NOWRAP="true"> </TD></TR></TABLE>
<TABLE CLASS="buttonbartable" CELLSPACING="0">
<TR ID="hdr">
<TD NOWRAP="true" CLASS="runninghead">Debugging Tools for Windows</TD>
</TR>
</TABLE>
<H1><A NAME="t13_advanced_cc933b2b-4388-4b51-9950-d62953991b10.xml"></A>Debugging a Deadlock</H1>
<P>When a thread needs exclusive access to code or some other resource, it requests a <i>lock</i>. If it can, Windows responds by giving this lock to the thread. At this point, nothing else in the system can access the locked code. This happens all the time and is a normal part of any well-written multithreaded application. Although a particular code segment can only have one lock on it at a time, multiple code segments can each have their own lock.</P>
<P>A <i>deadlock</i> arises when two or more threads have requested locks on two or more resources, in an incompatible sequence.  For instance, suppose that Thread One has acquired a lock on Resource A and then requests access to Resource B.  Meanwhile, Thread Two has acquired a lock on Resource B and then requests access to Resource A.  Neither thread can proceed until the other thread's lock is relinquished, and, therefore, neither thread can proceed. </P>
<P>User-mode deadlocks arise when multiple threads of one application have blocked each others' access to the same resources.  Kernel-mode deadlocks arise when multiple threads (from the same process or from distinct processes) have blocked each others' access to the same kernel resource.  The procedure used to debug a deadlock depends on whether the deadlock occurs in user mode or in kernel mode.</P>
<P></P>
<H4>Debugging a User-Mode Deadlock</H4>
<P>When a deadlock occurs in user mode, use the following procedure to debug it:</P><B></B><OL type="1">
<LI>Issue the <a href="r31_exts_user_719ca52d-1eb4-4877-a644-4f6eff6f94dc.xml.htm"><b>!ntsdexts.locks</b></a> extension. In user mode, you can just type <b>!locks</b> at the debugger prompt; the <i>ntsdexts</i> prefix is assumed.</LI>
<LI>This extension displays all the critical sections associated with the current process, along with the ID for the owning thread and the lock count for each critical section. If a critical section has a lock count of zero, it is not locked. Use the <a href="r15_cmds_a_e8b03a38-abea-4e4f-9429-a89f4638905b.xml.htm"><b>~ (Thread Status)</b></a> command to see information about the threads that own the other critical sections. </LI>
<LI>Use the <a href="r17_cmds_i_58e69e42-fcda-4972-9358-60ab7a6e1def.xml.htm"><b>kb (Display Stack Backtrace)</b></a> command for each of these threads to determine whether they are waiting on other critical sections.</LI>
<LI>Using the output of these <b>kb</b> commands, you can find the deadlock: two threads that are each waiting on a lock held by the other thread. In rare cases, a deadlock could be caused by more than two threads holding locks in a circular pattern, but most deadlocks involve only two threads.</LI>
</OL>
<P></P>
<P>Here is an illustration of this procedure.  You begin with the <b>!ntdexts.locks</b> extension: </P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:006&gt;  <b>!locks </b><BR>CritSec ftpsvc2!g_csServiceEntryLock+0 at 6833dd68<BR>LockCount          0<BR>RecursionCount     1<BR>OwningThread       a7<BR>EntryCount         0<BR>ContentionCount    0<BR>*** Locked<BR> <BR>CritSec isatq!AtqActiveContextList+a8 at 68629100<BR>LockCount          2<BR>RecursionCount     1<BR>OwningThread       a3<BR>EntryCount         2<BR>ContentionCount    2<BR>*** Locked<BR> <BR>CritSec +24e750 at 24e750<BR>LockCount          6<BR>RecursionCount     1<BR>OwningThread       a9<BR>EntryCount         6<BR>ContentionCount    6<BR>*** Locked <BR></nobr></P>
<P>The first critical section displayed has no locks and, therefore, can be ignored.</P>
<P>The second critical section displayed has a lock count of 2 and is, therefore, a possible cause of a deadlock. The owning thread has a thread ID of 0xA3.</P>
<P>You can find this thread by listing all threads with the <a href="r15_cmds_a_e8b03a38-abea-4e4f-9429-a89f4638905b.xml.htm"><b>~ (Thread Status)</b></a> command, and looking for the thread with this ID:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:006&gt;  <b>~</b> <BR>   0  Id: 1364.1330 Suspend: 1 Teb: 7ffdf000 Unfrozen<BR>   1  Id: 1364.17e0 Suspend: 1 Teb: 7ffde000 Unfrozen<BR>   2  Id: 1364.135c Suspend: 1 Teb: 7ffdd000 Unfrozen<BR>   3  Id: 1364.1790 Suspend: 1 Teb: 7ffdc000 Unfrozen<BR>   4  Id: 1364.a3 Suspend: 1 Teb: 7ffdb000 Unfrozen<BR>   5  Id: 1364.1278 Suspend: 1 Teb: 7ffda000 Unfrozen<BR>.  6  Id: 1364.a9 Suspend: 1 Teb: 7ffd9000 Unfrozen<BR>   7  Id: 1364.111c Suspend: 1 Teb: 7ffd8000 Unfrozen<BR>   8  Id: 1364.1588 Suspend: 1 Teb: 7ffd7000 Unfrozen <BR></nobr></P>
<P>In this display, the first item is the debugger's internal thread number. The second item (the <span style="cursor:text; font: 100% Courier New, Courier, mono; color: #660000;">Id</span> field) contains two hexadecimal numbers separated by a decimal point. The number before the decimal point is the process ID; the number after the decimal point is the thread ID. In this example, you see that thread ID 0xA3 corresponds to thread number 4.</P>
<P>You then use the <a href="r17_cmds_i_58e69e42-fcda-4972-9358-60ab7a6e1def.xml.htm"><b>kb (Display Stack Backtrace)</b></a> command to display the stack that corresponds to thread number 4:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:006&gt;  <b>~4 kb</b> <BR>  4  id: 97.a3   Suspend: 0 Teb 7ffd9000 Unfrozen<BR>ChildEBP RetAddr  Args to Child<BR>014cfe64 77f6cc7b 00000460 00000000 00000000 ntdll!NtWaitForSingleObject+0xb<BR>014cfed8 77f67456 <b>0024e750</b> 6833adb8 0024e750 <b>ntdll!RtlpWaitForCriticalSection+0xaa</b> <BR>014cfee0 6833adb8 0024e750 80000000 01f21cb8 ntdll!RtlEnterCriticalSection+0x46<BR>014cfef4 6833ad8f 01f21cb8 000a41f0 014cff20 ftpsvc2!DereferenceUserDataAndKill+0x24<BR>014cff04 6833324a 01f21cb8 00000000 00000079 ftpsvc2!ProcessUserAsyncIoCompletion+0x2a<BR>014cff20 68627260 01f21e0c 00000000 00000079 ftpsvc2!ProcessAtqCompletion+0x32<BR>014cff40 686249a5 000a41f0 00000001 686290e8 isatq!I_TimeOutContext+0x87<BR>014cff5c 68621ea7 00000000 00000001 0000001e isatq!AtqProcessTimeoutOfRequests_33+0x4f<BR>014cff70 68621e66 68629148 000ad1b8 686230c0 isatq!I_AtqTimeOutWorker+0x30<BR>014cff7c 686230c0 00000000 00000001 000c000a isatq!I_AtqTimeoutCompletion+0x38<BR>014cffb8 77f04f2c 00000000 00000001 000c000a isatq!SchedulerThread_297+0x2f<BR>00000001 000003e6 00000000 00000001 000c000a kernel32!BaseThreadStart+0x51<BR></nobr></P>
<P>Notice that this thread has a call to the <b>WaitForCriticalSection</b> function<i>,</i> which means that not only does it have a lock, it is waiting for code that is locked by something else. We can find out which critical section we are waiting on by looking at the first parameter of the call to <b>WaitForCriticalSection</b>. This is the first address under <b>Args to Child</b>: "24e750".  So this thread is waiting on the critical section at address 0x24E750. This was the third critical section listed by the <b>!locks</b> extension that you used earlier.</P>
<P>In other words, thread 4, which owns the second critical section, is waiting on the third critical section. Now turn your attention to the third critical section, which is also locked. The owning thread has thread ID 0xA9. Returning to the output of the <b>~</b> command that you saw previously, note that the thread with this ID is thread number 6.  Display the stack backtrace for this thread:</P>
<P style="cursor:text; padding:2pt,4pt;font: 100% Courier New, Courier, mono; color: #660000;"><nobr>0:006&gt;  <b>~6 kb</b> <BR>ChildEBP RetAddr  Args to Child<BR>0155fe38 77f6cc7b 00000414 00000000 00000000 ntdll!NtWaitForSingleObject+0xb<BR>0155feac 77f67456 <b>68629100</b> 6862142e 68629100 <b>ntdll!RtlpWaitForCriticalSection+0xaa</b> <BR>0155feb4 6862142e 68629100 0009f238 686222e1 ntdll!RtlEnterCriticalSection+0x46<BR>0155fec0 686222e1 0009f25c 00000001 0009f238 isatq!ATQ_CONTEXT_LISTHEAD__RemoveFromList<BR>0155fed0 68621412 0009f238 686213d1 0009f238 isatq!ATQ_CONTEXT__CleanupAndRelease+0x30<BR>0155fed8 686213d1 0009f238 00000001 01f26bcc isatq!AtqpReuseOrFreeContext+0x3f<BR>0155fee8 683331f7 0009f238 00000001 01f26bf0 isatq!AtqFreeContext+0x36<BR>0155fefc 6833984b ffffffff 00000000 00000000 ftpsvc2!ASYNC_IO_CONNECTION__SetNewSocket<BR>0155ff18 6833adcd 77f05154 01f26a58 00000000 ftpsvc2!USER_DATA__Cleanup+0x47<BR>0155ff28 6833ad8f 01f26a58 000a3410 0155ff54 ftpsvc2!DereferenceUserDataAndKill+0x39<BR>0155ff38 6833324a 01f26a58 00000000 00000040 ftpsvc2!ProcessUserAsyncIoCompletion+0x2a<BR>0155ff54 686211eb 01f26bac 00000000 00000040 ftpsvc2!ProcessAtqCompletion+0x32<BR>0155ff88 68622676 000a3464 00000000 000a3414 isatq!AtqpProcessContext+0xa7<BR>0155ffb8 77f04f2c abcdef01 ffffffff 000ad1b0 isatq!AtqPoolThread+0x32<BR>0155ffec 00000000 68622644 abcdef01 00000000 kernel32!BaseThreadStart+0x51<BR></nobr></P>
<P>This thread, too, is waiting for a critical section to be freed. In this case, it is waiting on the critical section at 0x68629100. This was the second critical section in the list generated earlier by the <b>!locks</b> extension.</P>
<P>This is the deadlock. Thread 4, which owns the second critical section, is waiting on the third critical section. Thread 6, which owns the third critical section, is waiting on the second critical section. </P>
<P>Having confirmed the nature of this deadlock, you can use the usual debugging techniques to analyze threads 4 and 6.</P>
<P></P>
<H4>Debugging a Kernel-Mode Deadlock</H4>
<P>There are several debugger extensions that are useful for debugging deadocks in kernel mode:</P><B></B><UL type="disc">
<LI>The <a href="r27_exts_kernel_e_0a5e2949-f4ab-488f-bf59-72c3e15d7643.xml.htm"><b>!kdexts.locks</b></a> extension displays information about all locks held on kernel resources and the threads holding these locks. (In kernel mode, you can just type <b>!locks</b> at the debugger prompt; the <i>kdexts</i> prefix is assumed.) </LI>
<LI>The <a href="r29_exts_kernel_q_23790fbd-4598-4b77-bd98-738cbd9cdaa3.xml.htm"><b>!qlocks</b></a> extension displays the state of all queued spin locks. </LI>
<LI>The <a href="r26_exts_kernel_a_e10a3a85-32de-4854-b6ea-c877b0650ea6.xml.htm"><b>!wdfkd.wdfspinlock</b></a> extension displays information about a Kernel-Mode Driver Framework (KMDF) spin-lock object. </LI>
<LI>The <a href="r26_exts_kernel_a_e10a3a85-32de-4854-b6ea-c877b0650ea6.xml.htm"><b>!deadlock</b></a> extension is used in conjunction with Driver Verifier to detect inconsistent use of locks in your code that have the potential to cause deadlocks. </LI>
</UL>
<P></P>
<P>When a deadlock occurs in kernel mode, use the <b>!kdexts.locks</b> extension to list all the locks currently acquired by threads.</P>
<P>You can usually pinpoint the deadlock by finding one non-executing thread that holds an exclusive lock on a resource that is required by an executing thread. Most of the locks are shared.</P>
<P></P>
<DIV style="display:yes"></DIV>
<DIV CLASS="footer"><br><A href="dbglegal.htm">© 2009 Microsoft Corporation</A><br><A href="mailto:windbgfb@microsoft.com?subject=documentation feedback [Debugger]: Debugging a Deadlock RELEASE: (December 09, 2009)&amp;body=%0A%0APRIVACY STATEMENT%0A%0AThe WDK team uses the feedback submitted to improve the WDK documentation. We do not use your e-mail address for any other purpose. We will remove your e-mail address from our system after the issue you are reporting has been resolved. While we are working to resolve this issue, we may send you an e-mail message to request more information about your feedback. After the issues have been addressed, we may send you an e-mail message to let you know that your feedback has been addressed.%0A%0AFor more information about Microsoft's privacy policy, see http://privacy.microsoft.com/en-us/default.aspx.
              ">Send feedback on this topic</A><br>Debugging Tools for Windows<br>December 09, 2009<br></DIV>
</Body>
</HTML>
